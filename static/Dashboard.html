<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Athena Skilled Nursing Facility Dashboard</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px 0;
            text-align: center;
            margin-bottom: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .section {
            background: white;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            border-left: 4px solid #667eea;
        }
        
        /* ============================================================
           REQUIRED: COLLAPSIBLE SECTIONS - DO NOT DELETE THIS BLOCK
           This CSS enables all sections to collapse/expand.
           ============================================================ */
        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5rem;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
        }
        .section-header-content {
            flex: 1;
        }
        .collapse-btn {
            background: transparent;
            border: none;
            color: #667eea;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 4px;
            transition: all 0.2s ease;
            margin-left: 15px;
        }
        .collapse-btn:hover {
            background: #f0f0f0;
            color: #556cd6;
        }
        .collapse-btn::after {
            content: '‚ñº';
        }
        .section-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        .section.collapsed .section-content {
            display: none;
        }
        .section.collapsed h2 .collapse-btn::after {
            content: '‚ñ∂';
        }
        /* ============================================================ */
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }
        
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            background-color: white;
            transition: border-color 0.3s ease;
        }
        
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .facility-info {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #e9ecef;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        .info-item {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border-left: 3px solid #667eea;
        }
        
        .info-label {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 5px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .info-value {
            color: #333;
            font-size: 1.1rem;
        }
        
        .placeholder {
            color: #999;
            font-style: italic;
            text-align: center;
            padding: 40px;
        }
        
        /* Map styles */
        .facility-marker {
            background: transparent;
            border: none;
            font-size: 20px;
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }
        
        #map {
            border: 2px solid #e1e5e9;
        }
        
        .map-controls {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        #dateSlider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #e1e5e9;
            outline: none;
        }
        
        #dateSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }
        
        #dateSlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }
        
        .loading {
            text-align: center;
            color: #667eea;
            padding: 20px;
        }
        
        .error {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #fcc;
            margin-top: 15px;
        }
        
        .timeline-container {
            position: relative;
            padding: 20px 0;
        }
        
        .timeline {
            position: relative;
            height: 120px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #e9ecef;
            margin: 20px 0;
            overflow: visible;
        }
        
        .timeline-line {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            background: #667eea;
            transform: translateY(-50%);
        }
        
        .timeline-marker {
            position: absolute;
            top: 50%;
            width: 12px;
            height: 12px;
            background: #667eea;
            border: 3px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .timeline-marker:hover {
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }
        
        .timeline-marker.active {
            background: #ff6b6b;
            border-color: white;
        }
        
        .timeline-date {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: #666;
            white-space: nowrap;
            margin-top: 8px;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #e0e0e0;
            z-index: 10;
            pointer-events: none;
        }
        
        .timeline-date.staggered {
            top: 120%;
        }
        
        .timeline-date.staggered-2 {
            top: 140%;
        }
        
        .timeline-date.staggered-3 {
            top: 160%;
        }
        
        .timeline-scale {
            position: absolute;
            bottom: -30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #666;
        }
        
        .timeline-scale-item {
            text-align: center;
            flex: 1;
        }
        
        .timeline-info {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            margin-top: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .timeline-info h4 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        .timeline-info p {
            margin: 5px 0;
            color: #555;
        }

        /* Forecast timeline styles */
        .forecast-timeline {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }

        .forecast-timeline h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.1rem;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 8px;
        }

        .forecast-summary {
            margin-top: 30px;
            padding: 20px;
            background: #e8f4fd;
            border-radius: 8px;
            border: 2px solid #667eea;
        }

        .forecast-summary h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .forecast-marker {
            position: absolute;
            top: 50%;
            width: 16px;
            height: 16px;
            background: #ff6b6b;
            border: 3px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 5;
        }

        .forecast-marker:hover {
            transform: translate(-50%, -50%) scale(1.3);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .forecast-marker::after {
            content: 'üîÆ';
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #e0e0e0;
            white-space: nowrap;
        }

        /* Simple histogram styles */
        .histogram {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 12px 16px 8px;
            height: 200px;
            position: relative;
            overflow: hidden;
        }
        .hist-bars {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            align-items: end;
            column-gap: 8px;
            height: 100%;
        }
        .hist-bar {
            background: #667eea;
            width: 100%;
            border-radius: 3px 3px 0 0;
            transition: height 0.3s ease;
        }
        .hist-axis {
            margin-top: 8px;
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            font-size: 0.75rem;
            color: #666;
            column-gap: 8px;
            text-align: center;
        }

        /* Buttons */
        .btn {
            display: inline-block;
            background: #667eea;
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 10px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        .btn:hover {
            background: #556cd6;
        }
        
        /* Peer timeline highlighting */
        .timeline-marker.dimmed {
            opacity: 0.2;
        }
        .legend-item {
            cursor: pointer;
            user-select: none;
        }
        .legend-item.active {
            font-weight: 600;
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .info-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Athena Skilled Nursing Facility Dashboard</h1>
            <p>Comprehensive facility information and analytics</p>
        </div>
        
        <!-- Section 1: State and Facility Selection -->
        <div class="section">
            <h2 onclick="toggleSection(this)">
                <span class="section-header-content">Facility Selection</span>
                <button class="collapse-btn" onclick="event.stopPropagation(); toggleSection(this.closest('h2'))"></button>
            </h2>
            <div class="section-content">
            <div class="form-row">
                <div class="form-group">
                    <label for="stateSelect">Select State:</label>
                    <select id="stateSelect" onchange="onStateChange()">
                        <option value="">Choose a state...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="facilitySelect">Select Facility:</label>
                    <select id="facilitySelect" onchange="onFacilityChange()" disabled>
                        <option value="">Choose a facility...</option>
                    </select>
                </div>
            </div>
            
            <div id="facilityInfo" class="facility-info" style="display: none;">
                <h3>Facility Information</h3>
                <div class="info-grid" id="infoGrid">
                    <!-- Facility information will be populated here -->
                </div>
            </div>
            </div>
        </div>
        
        <!-- Section 2: Health Survey Dates Timeline -->
        <div class="section">
            <h2 onclick="toggleSection(this)">
                <span class="section-header-content">Health Survey Dates</span>
                <button class="collapse-btn" onclick="event.stopPropagation(); toggleSection(this.closest('h2'))"></button>
            </h2>
            <div class="section-content">
            <div id="timelineContainer" class="timeline-container">
                <div class="placeholder">Select a state and facility to view survey dates timeline</div>
            </div>
            </div>
        </div>
        
        <!-- Section 3: Peer Timelines -->
        <div class="section">
            <h2 onclick="toggleSection(this)">
                <span class="section-header-content">Peer Survey Timelines</span>
                <button class="collapse-btn" onclick="event.stopPropagation(); toggleSection(this.closest('h2'))"></button>
            </h2>
            <div class="section-content">
            <div id="zipTimelineContainer" class="timeline-container">
                <h3 id="peerTimelineHeader">Timeline 1: County Facilities</h3>
                <div class="timeline">
                    <div class="timeline-line"></div>
                    <div class="timeline-scale" id="peerTimelineScale">
                        <div class="timeline-scale-item">1/1/2016</div>
                        <div class="timeline-scale-item">1/1/2018</div>
                        <div class="timeline-scale-item">1/1/2020</div>
                        <div class="timeline-scale-item">1/1/2022</div>
                        <div class="timeline-scale-item" id="peerTimelineEndDate"></div>
                    </div>
                </div>
                <div class="timeline-info" id="zipTimelineInfo">
                    <p>Select a facility to view peers in the same County/Parish.</p>
                </div>
            </div>
            </div>
        </div>
        
        <!-- Section 4: Monthly Survey Histograms -->
        <div class="section">
            <h2 onclick="toggleSection(this)">
                <span class="section-header-content">Section 4: Monthly Health Survey Dates</span>
                <button class="collapse-btn" onclick="event.stopPropagation(); toggleSection(this.closest('h2'))"></button>
            </h2>
            <div class="section-content">
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-top: 20px;">
                <div>
                    <h3>By State</h3>
                    <div id="histogramContainer">
                        <div class="placeholder">Select a state to view monthly survey counts</div>
                    </div>
                </div>
                <div>
                    <h3>By County</h3>
                    <div id="countyHistogramContainer">
                        <div class="placeholder">Select a facility to view county survey counts</div>
                    </div>
                </div>
                <div>
                    <h3>By ZIP Code</h3>
                    <div id="zipHistogramContainer">
                        <div class="placeholder">Select a facility to view ZIP survey counts</div>
                    </div>
                </div>
            </div>
            </div>
        </div>
        
        <!-- Section 5: Interactive Map -->
        <div class="section">
            <h2 onclick="toggleSection(this)">
                <span class="section-header-content">Section 5: Interactive State Map with Survey Timeline</span>
                <button class="collapse-btn" onclick="event.stopPropagation(); toggleSection(this.closest('h2'))"></button>
            </h2>
            <div class="section-content">
            <div id="mapContainer">
                <div id="map" style="height: 500px; width: 100%; border-radius: 8px;"></div>
                <div class="map-controls" style="margin-top: 15px;">
                    <label for="dateSlider" style="display: block; margin-bottom: 10px; font-weight: 600;">Survey Date Timeline:</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                        <button id="playPauseBtn" style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer;">‚ñ∂ Play</button>
                        <button id="resetBtn" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Reset</button>
                        <div style="flex: 1;">
                            <input type="range" id="dateSlider" min="0" max="100" value="0" style="width: 100%;">
                        </div>
                    </div>
                    <div id="dateDisplay" style="text-align: center; font-weight: 600; color: #667eea; font-size: 1.1rem; padding: 10px; background: #f8f9fa; border-radius: 5px; border: 1px solid #e1e5e9;">Select a state to load timeline</div>
                    <div id="surveyCount" style="text-align: center; color: #666; font-size: 0.9rem; margin-top: 5px;"></div>
                </div>
            </div>
            </div>
        </div>

        <!-- Section 6: Forecasts -->
        <div class="section">
            <h2 onclick="toggleSection(this)">
                <span class="section-header-content">Section 6: Forecasts</span>
                <button class="collapse-btn" onclick="event.stopPropagation(); toggleSection(this.closest('h2'))"></button>
            </h2>
            <div class="section-content">
            <p>Six different forecasting models for the next facility visit based on historical survey patterns.</p>
            
            <!-- Timeline 1: State Average -->
            <div class="forecast-timeline">
                <h3>Timeline 1: State Average</h3>
                <div class="timeline-container">
                <div class="timeline">
                    <div class="timeline-line"></div>
                    <div class="timeline-scale">
                        <div class="timeline-scale-item">1/1/2016</div>
                        <div class="timeline-scale-item">1/1/2018</div>
                        <div class="timeline-scale-item">1/1/2020</div>
                        <div class="timeline-scale-item">1/1/2022</div>
                            <div class="timeline-scale-item">1/1/2025</div>
                            <div class="timeline-scale-item">12/31/2027</div>
                    </div>
                </div>
                    <div class="timeline-info" id="forecastTimeline1Info">
                        <p>Select a facility to view forecast based on state average time between surveys.</p>
                </div>
            </div>
        </div>
        
            <!-- Timeline 2: County/Parish Average -->
            <div class="forecast-timeline">
                <h3>Timeline 2: County/Parish Average</h3>
                <div class="timeline-container">
                    <div class="timeline">
                        <div class="timeline-line"></div>
                        <div class="timeline-scale">
                            <div class="timeline-scale-item">1/1/2016</div>
                            <div class="timeline-scale-item">1/1/2018</div>
                            <div class="timeline-scale-item">1/1/2020</div>
                            <div class="timeline-scale-item">1/1/2022</div>
                            <div class="timeline-scale-item">1/1/2025</div>
                            <div class="timeline-scale-item">12/31/2027</div>
                        </div>
                    </div>
                    <div class="timeline-info" id="forecastTimeline2Info">
                        <p>Select a facility to view forecast based on County/Parish average time between surveys.</p>
                    </div>
            </div>
        </div>
        
            <!-- Timeline 3: Similar Characteristics -->
            <div class="forecast-timeline">
                <h3>Timeline 3: Similar Characteristics</h3>
                <div class="timeline-container">
                    <div class="timeline">
                        <div class="timeline-line"></div>
                        <div class="timeline-scale">
                            <div class="timeline-scale-item">1/1/2016</div>
                            <div class="timeline-scale-item">1/1/2018</div>
                            <div class="timeline-scale-item">1/1/2020</div>
                            <div class="timeline-scale-item">1/1/2022</div>
                            <div class="timeline-scale-item">1/1/2025</div>
                            <div class="timeline-scale-item">12/31/2027</div>
                </div>
                </div>
                    <div class="timeline-info" id="forecastTimeline3Info">
                        <p>Select a facility to view forecast based on similar facility characteristics.</p>
            </div>
                </div>
            </div>

            <!-- Timeline 4: Similar Deficiencies -->
            <div class="forecast-timeline">
                <h3>Timeline 4: Similar Deficiencies</h3>
                <div class="timeline-container">
                    <div class="timeline">
                        <div class="timeline-line"></div>
                        <div class="timeline-scale">
                            <div class="timeline-scale-item">1/1/2016</div>
                            <div class="timeline-scale-item">1/1/2018</div>
                            <div class="timeline-scale-item">1/1/2020</div>
                            <div class="timeline-scale-item">1/1/2022</div>
                            <div class="timeline-scale-item">1/1/2025</div>
                            <div class="timeline-scale-item">12/31/2027</div>
                        </div>
                    </div>
                    <div class="timeline-info" id="forecastTimeline4Info">
                        <p>Select a facility to view forecast based on similar historical deficiencies.</p>
                    </div>
                </div>
            </div>

            <!-- Timeline 5: State Average (Past 2 Years) -->
            <div class="forecast-timeline">
                <h3>Timeline 5: State Average (Past 2 Years)</h3>
                <div class="timeline-container">
                    <div class="timeline">
                        <div class="timeline-line"></div>
                        <div class="timeline-scale">
                            <div class="timeline-scale-item">1/1/2016</div>
                            <div class="timeline-scale-item">1/1/2018</div>
                            <div class="timeline-scale-item">1/1/2020</div>
                            <div class="timeline-scale-item">1/1/2022</div>
                            <div class="timeline-scale-item">1/1/2025</div>
                            <div class="timeline-scale-item">12/31/2027</div>
                        </div>
                    </div>
                    <div class="timeline-info" id="forecastTimeline5Info">
                        <p>Select a facility to view forecast based on state average over past 2 years.</p>
                    </div>
                </div>
            </div>

            <!-- Timeline 6: Combined Criteria (Past 2 Years) -->
            <div class="forecast-timeline">
                <h3>Timeline 6: Combined Criteria (Past 2 Years)</h3>
                <div class="timeline-container">
                    <div class="timeline">
                        <div class="timeline-line"></div>
                        <div class="timeline-scale">
                            <div class="timeline-scale-item">1/1/2016</div>
                            <div class="timeline-scale-item">1/1/2018</div>
                            <div class="timeline-scale-item">1/1/2020</div>
                            <div class="timeline-scale-item">1/1/2022</div>
                            <div class="timeline-scale-item">1/1/2025</div>
                            <div class="timeline-scale-item">12/31/2027</div>
                        </div>
                    </div>
                    <div class="timeline-info" id="forecastTimeline6Info">
                        <p>Select a facility to view forecast based on combined criteria over past 2 years.</p>
                    </div>
                </div>
            </div>
            
            <!-- Timeline 7: Machine Learning Forecast -->
            <div class="forecast-timeline">
                <h3>Timeline 7: Machine Learning Forecast</h3>
                <div class="timeline-container">
                    <div class="timeline">
                        <div class="timeline-line"></div>
                        <div class="timeline-scale">
                            <div class="timeline-scale-item">1/1/2016</div>
                            <div class="timeline-scale-item">1/1/2018</div>
                            <div class="timeline-scale-item">1/1/2020</div>
                            <div class="timeline-scale-item">1/1/2022</div>
                            <div class="timeline-scale-item">1/1/2025</div>
                            <div class="timeline-scale-item">12/31/2027</div>
                        </div>
                    </div>
                    <div class="timeline-info" id="forecastTimeline7Info">
                        <p>Select a facility to view a machine learning-based forecast using historical intervals and peer trends.</p>
                    </div>
                </div>
            </div>

            <!-- Average Forecast Summary -->
            <div class="forecast-summary">
                <h3>Average Forecast Date</h3>
                
                <!-- Timeline for Average Forecast -->
                <div class="timeline-container" style="margin-bottom: 20px;">
                    <div class="timeline">
                        <div class="timeline-line"></div>
                        <div class="timeline-scale">
                            <div class="timeline-scale-item">1/1/2016</div>
                            <div class="timeline-scale-item">1/1/2018</div>
                            <div class="timeline-scale-item">1/1/2020</div>
                            <div class="timeline-scale-item">1/1/2022</div>
                            <div class="timeline-scale-item">1/1/2025</div>
                            <div class="timeline-scale-item">12/31/2027</div>
                        </div>
                    </div>
                    <div class="timeline-info" id="averageForecastTimelineInfo">
                        <p>Select a facility to view historical survey dates and average forecast.</p>
                    </div>
                </div>
                
                <div id="averageForecastDisplay" class="facility-info">
                <div class="info-item">
                        <div class="info-label">Predicted Next Survey Date</div>
                        <div class="info-value" id="averageForecastValue">Select a facility to view forecast</div>
                    </div>
                </div>
                
                <!-- Calendar Control Section -->
                <div class="calendar-control-section" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px; border: 1px solid #dee2e6;">
                    <h4 style="margin-bottom: 15px; color: #495057; font-size: 1rem;">Select Date of Expected Next Visit</h4>
                    <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap; margin-bottom: 15px;">
                        <div style="display: flex; flex-direction: column; gap: 5px;">
                            <label for="customDateInput" style="font-weight: 600; color: #495057; font-size: 0.9rem;">Select Date:</label>
                            <input type="date" id="customDateInput" style="padding: 8px 12px; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.9rem; min-width: 150px;">
                        </div>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 5px; margin-bottom: 15px;">
                        <label for="AdditionalInfo" style="font-weight: 600; color: #495057; font-size: 0.9rem;">Additional Information:</label>
                        <textarea id="AdditionalInfo" rows="4" placeholder="Paste additional information here (e.g., facility mission, special considerations, etc.)" style="padding: 8px 12px; border: 1px solid #ced4da; border-radius: 4px; font-size: 0.9rem; width: 100%; font-family: inherit; resize: vertical;"></textarea>
                        <p style="margin-top: 5px; font-size: 0.8rem; color: #6c757d; font-style: italic;">Include facility mission, special considerations, or other information to be incorporated into the schedule generation.</p>
                    </div>
                    <div style="display: flex; align-items: center;">
                        <button id="generatePromptBtn" onclick="generatePrompt()" style="padding: 8px 20px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; font-weight: 600; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#5a6fd8'" onmouseout="this.style.backgroundColor='#667eea'">
                            Generate Prompt
                        </button>
                    </div>
                    <p style="margin-top: 10px; font-size: 0.8rem; color: #6c757d; font-style: italic;">Use the calendar to select a custom date, or the default will be set to the calculated average forecast date.</p>
                </div>
            </div>
            </div>
        </div>
        
        <!-- Section 7: Placeholder for future content -->
        <div class="section">
            <h2 onclick="toggleSection(this)">
                <span class="section-header-content">Section 7: Health Deficiencies Prompt Builder</span>
                <button class="collapse-btn" onclick="event.stopPropagation(); toggleSection(this.closest('h2'))"></button>
            </h2>
            <div class="section-content">
            <div id="deficienciesContainer">
                <div class="placeholder">Select a state and facility to load deficiency details.</div>
            </div>
            </div>
        </div>

        <!-- Section 8: Prompt Builder Output -->
        <div class="section" id="promptSection" style="display:none;">
            <h2 onclick="toggleSection(this)">
                <span class="section-header-content">Section 8: Prompt for Schedule Generation</span>
                <button class="collapse-btn" onclick="event.stopPropagation(); toggleSection(this.closest('h2'))"></button>
            </h2>
            <div class="section-content">
            <div class="facility-info" style="margin-top: 10px;">
                <div class="info-item" style="grid-column: 1 / -1;">
                    <div class="info-label">Generated Prompt</div>
                    <div class="info-value">
                        <textarea id="promptTextarea" rows="12" style="width:100%; font-family: monospace;"> </textarea>
                    </div>
                </div>
                <div class="info-item" style="grid-column: 1 / -1; display:flex; gap:10px;">
                    <button id="getScheduleBtn" style="padding: 8px 16px; background: #10B981; color: white; border: none; border-radius: 4px; cursor: pointer;">Get Schedule</button>
                </div>
            </div>
            </div>
        </div>

        <!-- Section 9: Schedule Output -->
        <div class="section" id="scheduleSection" style="display:none;">
            <h2 onclick="toggleSection(this)">
                <span class="section-header-content">Section 9: Generated Schedule</span>
                <button class="collapse-btn" onclick="event.stopPropagation(); toggleSection(this.closest('h2'))"></button>
            </h2>
            <div class="section-content">
            <div class="facility-info" style="margin-top: 10px;">
                <div class="info-item" style="grid-column: 1 / -1;">
                    <div class="info-label">GenAI Output</div>
                    <div class="info-value">
                        <pre id="genaiOutput" style="white-space: pre-wrap; background:#f8f9fa; padding:10px; border:1px solid #e5e7eb; border-radius:4px; min-height:120px;"></pre>
                    </div>
                </div>
                <div class="info-item" style="grid-column: 1 / -1;">
                    <div class="info-label">ToDoist JSON</div>
                    <div class="info-value">
                        <textarea id="todoistJson" rows="10" style="width:100%; font-family: monospace;"></textarea>
                        <div style="margin-top:8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
                            <input id="todoistTokenInput" type="password" placeholder="Enter Todoist token" style="flex:1 1 320px; padding:8px; border:1px solid #ddd; border-radius:4px;" />
                            <button id="importTodoistBtn" style="padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer;">Import into ToDoIst</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        /* ============================================================
           REQUIRED: COLLAPSIBLE SECTIONS FUNCTION - DO NOT DELETE
           This function enables all sections to collapse/expand.
           ============================================================ */
        function toggleSection(headerElement) {
            if (!headerElement) return;
            const section = headerElement.closest('.section');
            if (!section) return;
            section.classList.toggle('collapsed');
        }
        /* ============================================================ */
        
        let facilitiesData = [];
        const peerTimelineSelection = {}; // containerId -> selected facility key
        
        // Map variables
        let map = null;
        let stateLayer = null;
        let facilityMarkers = [];
        let surveyData = [];
        let dateRange = { min: null, max: null };
        
        // Auto-play variables
        let isPlaying = false;
        let playInterval = null;
        let playSpeed = 100; // milliseconds between updates
        
        // Initialize the map
        function initializeMap() {
            if (map) {
                map.remove();
            }
            
            map = L.map('map').setView([39.8283, -98.5795], 4); // Center of US
            
            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);
        }
        
        // Populate state dropdown from API
        async function populateStateDropdown() {
            console.log('populateStateDropdown() called');
            const stateSelect = document.getElementById('stateSelect');
            if (!stateSelect) {
                console.error('‚ùå State select element not found in populateStateDropdown');
                populateFallbackStates();
                return;
            }
            
            console.log('Fetching states from /api/states...');
            try {
                const response = await fetch('/api/states');
                console.log('API response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API error response:', errorText);
                    throw new Error(`Failed to fetch states: ${response.status} ${errorText}`);
                }
                
                const data = await response.json();
                console.log('API response data:', data);
                
                // Clear existing options except the first one
                stateSelect.innerHTML = '<option value="">Choose a state...</option>';
                
                // Add states from API
                if (data.states && data.states.length > 0) {
                    console.log(`Found ${data.states.length} states from API`);
                    const sorted = [...data.states].sort((a, b) => getStateName(a).localeCompare(getStateName(b)));
                    sorted.forEach(stateCode => {
                        const option = document.createElement('option');
                        option.value = stateCode;
                        option.textContent = getStateName(stateCode);
                        stateSelect.appendChild(option);
                    });
                    
                    console.log(`‚úÖ Successfully populated state dropdown with ${data.states.length} states from API`);
                } else {
                    console.warn('‚ö†Ô∏è No states returned from API (data.states is empty or missing), using fallback');
                    // Fallback to hardcoded states if API fails
                    populateFallbackStates();
                }
            } catch (error) {
                console.error('‚ùå Error populating state dropdown:', error);
                console.error('Error details:', error.message, error.stack);
                // Fallback to hardcoded states
                populateFallbackStates();
            }
        }
        
        // Get full state name from state code
        function getStateName(stateCode) {
            const stateNames = {
                'AL': 'Alabama', 'AK': 'Alaska', 'AZ': 'Arizona', 'AR': 'Arkansas', 'CA': 'California',
                'CO': 'Colorado', 'CT': 'Connecticut', 'DE': 'Delaware', 'FL': 'Florida', 'GA': 'Georgia',
                'HI': 'Hawaii', 'ID': 'Idaho', 'IL': 'Illinois', 'IN': 'Indiana', 'IA': 'Iowa',
                'KS': 'Kansas', 'KY': 'Kentucky', 'LA': 'Louisiana', 'ME': 'Maine', 'MD': 'Maryland',
                'MA': 'Massachusetts', 'MI': 'Michigan', 'MN': 'Minnesota', 'MS': 'Mississippi', 'MO': 'Missouri',
                'MT': 'Montana', 'NE': 'Nebraska', 'NV': 'Nevada', 'NH': 'New Hampshire', 'NJ': 'New Jersey',
                'NM': 'New Mexico', 'NY': 'New York', 'NC': 'North Carolina', 'ND': 'North Dakota', 'OH': 'Ohio',
                'OK': 'Oklahoma', 'OR': 'Oregon', 'PA': 'Pennsylvania', 'RI': 'Rhode Island', 'SC': 'South Carolina',
                'SD': 'South Dakota', 'TN': 'Tennessee', 'TX': 'Texas', 'UT': 'Utah', 'VT': 'Vermont',
                'VA': 'Virginia', 'WA': 'Washington', 'WV': 'West Virginia', 'WI': 'Wisconsin', 'WY': 'Wyoming'
            };
            return stateNames[stateCode] || stateCode;
        }
        
        // Fallback function to populate states if API fails
        function populateFallbackStates() {
            console.log('populateFallbackStates() called - using hardcoded states');
            const stateSelect = document.getElementById('stateSelect');
            if (!stateSelect) {
                console.error('‚ùå State select element not found in populateFallbackStates');
                return;
            }
            
            const allStates = [
                'AL', 'AK', 'AZ', 'AR', 'CA', 'CO', 'CT', 'DE', 'FL', 'GA',
                'HI', 'ID', 'IL', 'IN', 'IA', 'KS', 'KY', 'LA', 'ME', 'MD',
                'MA', 'MI', 'MN', 'MS', 'MO', 'MT', 'NE', 'NV', 'NH', 'NJ',
                'NM', 'NY', 'NC', 'ND', 'OH', 'OK', 'OR', 'PA', 'RI', 'SC',
                'SD', 'TN', 'TX', 'UT', 'VT', 'VA', 'WA', 'WV', 'WI', 'WY'
            ];
            
            stateSelect.innerHTML = '<option value="">Choose a state...</option>';
            const sortedStates = allStates
                .sort((a, b) => getStateName(a).localeCompare(getStateName(b)));
            
            sortedStates.forEach(stateCode => {
                const option = document.createElement('option');
                option.value = stateCode;
                option.textContent = getStateName(stateCode);
                stateSelect.appendChild(option);
            });
            
            console.log(`‚úÖ Populated state dropdown with ${sortedStates.length} fallback states`);
            
            console.log('‚úÖ Populated state dropdown with fallback states');
        }
        
        // Load state boundaries and highlight selected county
        async function loadStateMap(state) {
            if (!map) return;
            
            // Clear existing layers
            if (stateLayer) {
                map.removeLayer(stateLayer);
            }
            facilityMarkers.forEach(marker => map.removeLayer(marker));
            facilityMarkers = [];
            
            // Comprehensive state coordinates for all 50 US states
            const stateCoords = {
                'AL': [32.3182, -86.9023],  // Alabama
                'AK': [64.2008, -149.4937], // Alaska
                'AZ': [33.7298, -111.4312], // Arizona
                'AR': [34.9697, -92.3731],  // Arkansas
                'CA': [36.7783, -119.4179], // California
                'CO': [39.0598, -105.3111], // Colorado
                'CT': [41.5978, -72.7554],  // Connecticut
                'DE': [39.3185, -75.5071],  // Delaware
                'FL': [27.7663, -81.6868],  // Florida
                'GA': [32.1656, -82.9001],  // Georgia
                'HI': [21.0943, -157.4983], // Hawaii
                'ID': [44.2405, -114.4788], // Idaho
                'IL': [40.3495, -88.9861],  // Illinois
                'IN': [39.8494, -86.2583],  // Indiana
                'IA': [42.0115, -93.2105],  // Iowa
                'KS': [38.5266, -96.7265],  // Kansas
                'KY': [37.6681, -84.6701],  // Kentucky
                'LA': [31.1695, -91.8678],  // Louisiana
                'ME': [44.3235, -69.7653],  // Maine
                'MD': [39.0639, -76.8021],  // Maryland
                'MA': [42.2302, -71.5301],  // Massachusetts
                'MI': [43.3266, -84.5361],  // Michigan
                'MN': [45.6945, -93.9002],  // Minnesota
                'MS': [32.3547, -89.3985],  // Mississippi
                'MO': [38.4561, -92.2884],  // Missouri
                'MT': [47.0526, -110.4544], // Montana
                'NE': [41.1254, -98.2681],  // Nebraska
                'NV': [38.4199, -117.1219], // Nevada
                'NH': [43.4525, -71.5639],  // New Hampshire
                'NJ': [40.2989, -74.5210],  // New Jersey
                'NM': [34.8405, -106.2485], // New Mexico
                'NY': [42.1657, -74.9481],  // New York
                'NC': [35.630066, -79.806419], // North Carolina
                'ND': [47.5289, -99.7840],  // North Dakota
                'OH': [40.3888, -82.7649],  // Ohio
                'OK': [35.5653, -96.9289],  // Oklahoma
                'OR': [43.8041, -120.5542], // Oregon
                'PA': [41.2033, -77.1945],  // Pennsylvania
                'RI': [41.6809, -71.5118],  // Rhode Island
                'SC': [33.856892, -80.945007], // South Carolina
                'SD': [44.2998, -99.4388],  // South Dakota
                'TN': [35.7478, -86.6923],  // Tennessee
                'TX': [31.9686, -99.9018],  // Texas
                'UT': [40.1500, -111.8624], // Utah
                'VT': [44.0459, -72.7107],  // Vermont
                'VA': [37.7693, -78.1699],  // Virginia
                'WA': [47.4009, -121.4905], // Washington
                'WV': [38.4912, -80.9545],  // West Virginia
                'WI': [44.2685, -89.6165],  // Wisconsin
                'WY': [42.7559, -107.3025]  // Wyoming
            };
            
            if (stateCoords[state]) {
                map.setView(stateCoords[state], 7);
                console.log(`Centered map on ${state} at coordinates:`, stateCoords[state]);
            } else {
                console.log(`No coordinates found for state: ${state}, using center of US as fallback`);
                // Fallback to center of US if state coordinates not found
                map.setView([39.8283, -98.5795], 4);
            }
        }
        
        // Load facilities for the selected state
        async function loadFacilitiesForMap(state) {
            try {
                const response = await fetch(`/api/facilities/${state}`);
                const data = await response.json();
                
                if (data.facilities) {
                    // Store facilities data globally for survey matching
                    facilitiesData = data.facilities;
                    console.log('üè• Set facilitiesData globally:', facilitiesData.length, 'facilities');
                    console.log('üè• facilitiesData is now available globally');
                    
                    console.log('üè• Loaded facilities data:', data.facilities.length, 'facilities');
                    if (data.facilities.length > 0) {
                        console.log('üè• Sample facility structure:', data.facilities[0]);
                        console.log('üè• Sample facility keys:', Object.keys(data.facilities[0]));
                        
                        // Test CCN extraction on the first facility
                        const testFacility = data.facilities[0];
                        const testCcn = testFacility.CCN || 
                                      testFacility.ccn || 
                                      testFacility['CMS Certification Number'] ||
                                      testFacility['CMS Certification Number (CCN)'] ||
                                      Object.values(testFacility)[0];
                        console.log('üè• Test CCN extraction:', testCcn);
                        console.log('üè• Test CCN type:', typeof testCcn);
                        
                        // Test all possible CCN fields
                        console.log('üè• All CCN field tests:');
                        console.log('  CCN:', testFacility.CCN);
                        console.log('  ccn:', testFacility.ccn);
                        console.log('  CMS Certification Number:', testFacility['CMS Certification Number']);
                        console.log('  CMS Certification Number (CCN):', testFacility['CMS Certification Number (CCN)']);
                        
                        // Auto-center map based on facility coordinates if available
                        const facilitiesWithCoords = data.facilities.filter(f => 
                            (f.lat && f.lng && f.lat !== 'null' && f.lng !== 'null' && 
                             f.lat !== 'undefined' && f.lng !== 'undefined')
                        );
                        
                        if (facilitiesWithCoords.length > 0) {
                            console.log(`üìç Found ${facilitiesWithCoords.length} facilities with coordinates for auto-centering`);
                            
                            // Calculate center point from facilities
                            let totalLat = 0, totalLng = 0;
                            facilitiesWithCoords.forEach(f => {
                                totalLat += parseFloat(f.lat);
                                totalLng += parseFloat(f.lng);
                            });
                            
                            const centerLat = totalLat / facilitiesWithCoords.length;
                            const centerLng = totalLng / facilitiesWithCoords.length;
                            
                            console.log(`üìç Auto-centering map on calculated center: [${centerLat}, ${centerLng}]`);
                            map.setView([centerLat, centerLng], 7);
                        } else {
                            console.log('üìç No facilities with coordinates found, using state coordinates');
                        }
                    }
                    
                    // Get the currently selected facility
                    const facilitySelect = document.getElementById('facilitySelect');
                    const selectedFacilityId = facilitySelect ? facilitySelect.value : null;
                    let selectedFacility = null;
                    
                    if (selectedFacilityId) {
                        selectedFacility = data.facilities.find(f => 
                            (f.unique_id || f.id || f.CCN || f['CMS Certification Number'] || f['CMS Certification Number (CCN)']) == selectedFacilityId
                        );
                    }
                    
                    data.facilities.forEach(facility => {
                        // Try different coordinate field names
                        const lat = facility.lat || facility.latitude || facility.LAT || facility.LATITUDE;
                        const lng = facility.lng || facility.longitude || facility.LNG || facility.LONGITUDE || facility.lon || facility.LON;
                        
                        if (lat && lng && lat !== 'null' && lng !== 'null' && lat !== 'undefined' && lng !== 'undefined') {
                            // Determine if this is the selected facility
                            const isSelectedFacility = selectedFacility && (
                                (facility.unique_id && facility.unique_id === selectedFacility.unique_id) ||
                                (facility.id && facility.id === selectedFacility.id) ||
                                (facility.CCN && facility.CCN === selectedFacility.CCN) ||
                                (facility['CMS Certification Number'] && facility['CMS Certification Number'] === selectedFacility['CMS Certification Number']) ||
                                (facility['CMS Certification Number (CCN)'] && facility['CMS Certification Number (CCN)'] === selectedFacility['CMS Certification Number (CCN)'])
                            );
                            
                            const marker = L.marker([parseFloat(lat), parseFloat(lng)], {
                                icon: L.divIcon({
                                    className: 'facility-marker',
                                    html: '‚òÖ',
                                    iconSize: [20, 20],
                                    iconAnchor: [10, 10]
                                }),
                                opacity: isSelectedFacility ? 1 : 0 // Only selected facility visible initially
                            }).addTo(map);
                            
                            // Get facility name from various possible fields
                            const facilityName = facility['Provider Name'] || facility.name || facility['Facility Name'] || 'Unknown Facility';
                            const facilityCcn = facility.CCN || facility.ccn || facility['CMS Certification Number'] || facility['CMS Certification Number (CCN)'] || 'N/A';
                            const facilityAddress = facility['Provider Address'] || facility.address || facility['Address'] || 'N/A';
                            
                            // Store facility info for later use
                            marker.facilityData = facility;
                            marker.isSelectedFacility = isSelectedFacility;
                            
                            marker.bindPopup(`
                                <strong>${facilityName}</strong><br>
                                CCN: ${facilityCcn}<br>
                                Address: ${facilityAddress}
                            `);
                            
                            facilityMarkers.push(marker);
                        }
                    });
                    
                    console.log(`Loaded ${data.facilities.length} facilities for map, ${facilityMarkers.length} with coordinates`);
                }
            } catch (error) {
                console.error('Error loading facilities for map:', error);
            }
        }
        
        // Load survey data for timeline
        async function loadSurveyDataForMap(state) {
            try {
                // Always use backend per-facility survey endpoint for accuracy
                console.log('üìä Loading per-facility survey dates from backend...');
                const resp = await fetch(`/api/state-facility-surveys/${encodeURIComponent(state)}`);
                if (!resp.ok) {
                    throw new Error(`Failed to load state facility surveys (${resp.status})`);
                }
                const payload = await resp.json();
                const records = Array.isArray(payload) ? payload : (payload.survey_dates || []);

                if (!Array.isArray(records) || records.length === 0) {
                    console.log('üìä No survey records returned for state');
                    surveyData = [];
                } else {
                    // Normalize into surveyData with Date objects
                    surveyData = records.map(r => ({
                        ccn: r.ccn,
                        date: new Date(r.date),
                        facility_name: r.facility_name || ''
                    })).filter(r => !isNaN(r.date));
                }

                // Establish date range from data
                if (surveyData.length > 0) {
                    const allDates = surveyData.map(s => s.date);
                    const minD = new Date(Math.min(...allDates.map(d => d.getTime())));
                    const maxD = new Date(Math.max(...allDates.map(d => d.getTime())));
                    dateRange.min = minD;
                    dateRange.max = maxD;

                    // Update slider bounds
                    const slider = document.getElementById('dateSlider');
                    if (slider) {
                        slider.min = 0;
                        slider.max = Math.max(0, Math.floor((dateRange.max - dateRange.min) / (1000 * 60 * 60 * 24)));
                    }

                    // Initialize date display
                    const sliderEl = document.getElementById('dateSlider');
                    if (sliderEl) {
                        updateDateDisplay(sliderEl.value);
                    }
                } else {
                    console.log('üìä No survey data to establish date range');
                    dateRange.min = null;
                    dateRange.max = null;
                }

                console.log(`üìä Loaded ${surveyData.length} survey events from backend.`);
            } catch (error) {
                console.error('Error loading survey data for map:', error);
                surveyData = [];
            }
        }
        
        // Update date display
        function updateDateDisplay(sliderValue) {
            const dateDisplay = document.getElementById('dateDisplay');
            if (dateRange.min && dateRange.max) {
                const currentDate = new Date(dateRange.min.getTime() + sliderValue * 24 * 60 * 60 * 1000);
                dateDisplay.textContent = currentDate.toLocaleDateString();
                console.log(`Date display updated: ${currentDate.toLocaleDateString()}`);
            } else {
                dateDisplay.textContent = 'No date range available';
                console.log('No date range available for display');
            }
        }
        
        // Auto-play functions
        function startAutoPlay() {
            if (isPlaying) return;
            
            isPlaying = true;
            const playBtn = document.getElementById('playPauseBtn');
            playBtn.textContent = '‚è∏ Pause';
            playBtn.style.background = '#dc3545';
            
            playInterval = setInterval(() => {
                const slider = document.getElementById('dateSlider');
                const currentValue = parseInt(slider.value);
                const maxValue = parseInt(slider.max);
                
                if (currentValue < maxValue) {
                    slider.value = currentValue + 1;
                    updateDateDisplay(slider.value);
                    updateMapForDate(slider.value);
                } else {
                    stopAutoPlay();
                }
            }, playSpeed);
        }
        
        function stopAutoPlay() {
            if (!isPlaying) return;
            
            isPlaying = false;
            const playBtn = document.getElementById('playPauseBtn');
            playBtn.textContent = '‚ñ∂ Play';
            playBtn.style.background = '#667eea';
            
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
            }
        }
        
        function resetTimeline() {
            stopAutoPlay();
            const slider = document.getElementById('dateSlider');
            slider.value = 0;
            updateDateDisplay(0);
            updateMapForDate(0);
        }
        
        // Update map based on slider position
        function updateMapForDate(sliderValue) {
            console.log('=== UPDATING MAP FOR DATE ===');
            console.log('Slider value:', sliderValue);
            
            if (!map || !dateRange.min) {
                console.log('‚ùå Map or date range not available');
                return;
            }
            
            // Helpers to normalize dates to UTC day keys
            const toUTCDate = (d) => new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
            const toYMD = (d) => {
                const y = d.getUTCFullYear();
                const m = String(d.getUTCMonth() + 1).padStart(2, '0');
                const dd = String(d.getUTCDate()).padStart(2, '0');
                return `${y}-${m}-${dd}`;
            };
            const daysBetweenUTC = (a, b) => {
                const ad = toUTCDate(a);
                const bd = toUTCDate(b);
                return Math.floor((ad - bd) / (1000 * 60 * 60 * 24));
            };
            
            const currentDate = new Date(dateRange.min.getTime() + sliderValue * 24 * 60 * 60 * 1000);
            const currentKey = toYMD(currentDate);
            
            console.log(`üìÖ Current date: ${currentDate.toDateString()} (UTC key ${currentKey})`);
            console.log(`üìä Survey data length: ${surveyData ? surveyData.length : 'undefined'}`);
            console.log(`üè• Facilities data length: ${facilitiesData ? facilitiesData.length : 'undefined'}`);
            console.log(`üìÖ Date range: ${dateRange.min.toDateString()} to ${dateRange.max.toDateString()}`);
            
            if (!surveyData || surveyData.length === 0) {
                console.log('‚ùå No survey data available');
                return;
            }
            
            console.log('üîç Checking surveys for date match...');
            console.log('üîç Survey data sample:', surveyData.slice(0, 3));
            console.log('üîç Current date:', currentDate.toDateString());
            
            // Group surveys by facility CCN for easier lookup
            const surveysByFacility = {};
            surveyData.forEach(survey => {
                if (!surveysByFacility[survey.ccn]) {
                    surveysByFacility[survey.ccn] = [];
                }
                // Attach normalized date key for reliable comparisons
                const d = survey.date instanceof Date ? survey.date : new Date(survey.date);
                surveysByFacility[survey.ccn].push({ ...survey, _dateKey: toYMD(d), _dateUTC: toUTCDate(d) });
            });
            
            console.log('üîç Surveys grouped by CCN:', Object.keys(surveysByFacility).slice(0, 5));
            console.log('üîç Total CCNs with surveys:', Object.keys(surveysByFacility).length);
            
            let surveysFound = 0;
            
            // Update facility marker visibility and colors
            facilityMarkers.forEach((marker, index) => {
                const facility = marker.facilityData;
                if (!facility) {
                    console.log(`üîç Marker ${index}: No facility data`);
                    return;
                }
                
                // Get facility CCN
                const facilityCcn = facility.CCN || 
                                  facility.ccn || 
                                  facility['CMS Certification Number'] ||
                                  facility['CMS Certification Number (CCN)'] ||
                                  facility.unique_id ||
                                  Object.values(facility)[0];
                
                console.log(`üîç Marker ${index}: CCN = ${facilityCcn}, isSelected = ${marker.isSelectedFacility}`);
                
                if (!facilityCcn) {
                    console.log(`üîç Marker ${index}: No CCN found`);
                    return;
                }
                
                // Find surveys for this facility
                const facilitySurveys = surveysByFacility[facilityCcn] || [];
                console.log(`üîç Marker ${index}: Found ${facilitySurveys.length} surveys for CCN ${facilityCcn}`);
                
                if (facilitySurveys.length > 0) {
                    console.log(`üîç Marker ${index}: Survey date keys:`, facilitySurveys.map(s => s._dateKey));
                }
                
                let markerOpacity = 0; // Default: hidden
                let markerColor = '#FFD700'; // Default: gold
                let markerSize = 20;
                
                // Check if this facility has a survey on the current date (UTC day)
                const surveyOnCurrentDate = facilitySurveys.find(survey => survey._dateKey === currentKey);
                
                if (surveyOnCurrentDate) {
                    // Survey on current date - bright red and visible
                    markerOpacity = 1;
                    markerColor = '#FF0000';
                    markerSize = 25;
                    surveysFound++;
                    console.log(`‚úÖ Survey on current date for facility ${facilityCcn}`);
                } else {
                    // Check if this facility has a survey within the last 28 days (UTC day diff)
                    const recentSurveys = facilitySurveys.filter(survey => {
                        const daysSinceSurvey = daysBetweenUTC(currentDate, survey._dateUTC);
                        return daysSinceSurvey >= 0 && daysSinceSurvey <= 28;
                    }).sort((a, b) => b._dateUTC - a._dateUTC);
                    
                    if (recentSurveys.length > 0) {
                        // Most recent survey within 28 days
                        const mostRecentSurvey = recentSurveys[0];
                        const daysSinceSurvey = daysBetweenUTC(currentDate, mostRecentSurvey._dateUTC);
                        
                        // Calculate fade opacity (1.0 on survey date, 0.0 after 28 days)
                        const fadeOpacity = Math.max(0, 1 - (daysSinceSurvey / 28));
                        
                        markerOpacity = fadeOpacity;
                        markerColor = '#FF0000';
                        markerSize = 20 + (fadeOpacity * 5); // Size decreases with opacity
                        
                        console.log(`üî¥ Facility ${facilityCcn}: Survey ${daysSinceSurvey} days ago, opacity: ${fadeOpacity.toFixed(2)}`);
                    } else if (marker.isSelectedFacility) {
                        // Selected facility - always show as gold when not showing red
                        markerOpacity = 1;
                        markerColor = '#FFD700';
                        markerSize = 20;
                        console.log(`‚≠ê Selected facility ${facilityCcn}: Showing as gold`);
                    }
                }
                
                // Update marker appearance
                marker.setOpacity(markerOpacity);
                marker.setIcon(L.divIcon({
                    className: 'facility-marker',
                    html: '‚òÖ',
                    iconSize: [markerSize, markerSize],
                    iconAnchor: [markerSize/2, markerSize/2]
                }));
                
                // Update marker color by changing the CSS
                const iconElement = marker.getElement();
                if (iconElement) {
                    iconElement.style.color = markerColor;
                    iconElement.style.textShadow = `0 0 3px ${markerColor}`;
                }
                
                // Update popup with survey info
                if (facilitySurveys.length > 0) {
                    // De-duplicate by UTC day key
                    const seen = new Set();
                    const uniqueDates = [];
                    facilitySurveys.forEach(s => {
                        const key = toYMD(s._dateUTC);
                        if (!seen.has(key)) {
                            seen.add(key);
                            uniqueDates.push(new Date(s._dateUTC));
                        }
                    });
                    // Sort ascending
                    uniqueDates.sort((a, b) => a - b);
                    const surveyInfo = uniqueDates.map(d => {
                        const daysSince = daysBetweenUTC(currentDate, d);
                        return `${d.toLocaleDateString()} (${daysSince} days ago)`;
                    }).join('<br>');
                    
                    marker.setPopupContent(`
                        <strong>${facility['Provider Name'] || facility.name || 'Unknown Facility'}</strong><br>
                        <strong>CCN:</strong> ${facilityCcn}<br>
                        <strong>Surveys:</strong><br>${surveyInfo}
                    `);
                }
            });
            
            console.log(`=== SUMMARY: Found ${surveysFound} surveys on ${currentDate.toDateString()} ===`);
            
            // Update survey count display
            const surveyCountEl = document.getElementById('surveyCount');
            if (surveyCountEl) {
                surveyCountEl.textContent = `Surveys on this date: ${surveysFound}`;
            }
        }
        
        async function onStateChange() {
            const stateSelect = document.getElementById('stateSelect');
            const facilitySelect = document.getElementById('facilitySelect');
            const facilityInfo = document.getElementById('facilityInfo');
            
            const selectedState = stateSelect.value;
            
            if (!selectedState) {
                facilitySelect.disabled = true;
                facilitySelect.innerHTML = '<option value="">Choose a facility...</option>';
                facilityInfo.style.display = 'none';
                
                // Clear timeline
                const timelineContainer = document.getElementById('timelineContainer');
                timelineContainer.innerHTML = '<div class="placeholder">Select a state and facility to view survey dates timeline</div>';

                // Clear histogram
                const histogramContainer = document.getElementById('histogramContainer');
                if (histogramContainer) histogramContainer.innerHTML = '<div class="placeholder">Select a state to view monthly survey counts</div>';
                return;
            }
            
            try {
                // Show loading state
                facilitySelect.innerHTML = '<option value="">Loading facilities...</option>';
                facilitySelect.disabled = true;
                
                // Fetch facilities for the selected state
                const response = await fetch(`/api/facilities/${selectedState}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch facilities');
                }
                
                const data = await response.json();
                console.log('API response:', data);
                facilitiesData = data.facilities;
                console.log('Facilities data:', facilitiesData);
                
                // Populate facility dropdown (alphabetically sorted)
                facilitySelect.innerHTML = '<option value="">Choose a facility...</option>';
                
                // Sort facilities alphabetically by name
                const sortedFacilities = facilitiesData.sort((a, b) => {
                    const nameA = a['Provider Name'] || a['provider_name'] || 
                                 a['Facility Name'] || a['facility_name'] || 
                                 a['Name'] || a['name'] || 'Unknown Facility';
                    const nameB = b['Provider Name'] || b['provider_name'] || 
                                 b['Facility Name'] || b['facility_name'] || 
                                 b['Name'] || b['name'] || 'Unknown Facility';
                    return nameA.localeCompare(nameB);
                });
                
                sortedFacilities.forEach((facility, index) => {
                    const option = document.createElement('option');
                    // Use unique_id if available (it's the index in the filtered list), otherwise use CCN or fallback to index
                    const facilityId = facility.unique_id !== undefined && facility.unique_id !== null 
                        ? facility.unique_id 
                        : (facility['CMS Certification Number (CCN)'] || facility['CMS Certification Number'] || facility.CCN || facility.id || index);
                    option.value = String(facilityId);
                    
                    // Get facility name from various possible columns
                    const facilityName = facility['Provider Name'] || facility['provider_name'] || 
                                       facility['Facility Name'] || facility['facility_name'] || 
                                       facility['Name'] || facility['name'] || 'Unknown Facility';
                    option.textContent = facilityName;
                    facilitySelect.appendChild(option);
                });
                
                facilitySelect.disabled = false;
                facilityInfo.style.display = 'none';
                
                // Clear timeline
                const timelineContainer = document.getElementById('timelineContainer');
                timelineContainer.innerHTML = '<div class="placeholder">Select a state and facility to view survey dates timeline</div>';

                // Render histogram for this state
                renderStateHistogram(selectedState);
                
            } catch (error) {
                console.error('Error fetching facilities:', error);
                facilitySelect.innerHTML = '<option value="">Error loading facilities</option>';
                facilitySelect.disabled = true;
            }
        }
        
        async function onFacilityChange() {
            const facilitySelect = document.getElementById('facilitySelect');
            const facilityInfo = document.getElementById('facilityInfo');
            const infoGrid = document.getElementById('infoGrid');
            
            const selectedFacilityId = facilitySelect.value;
            console.log('Selected facility ID:', selectedFacilityId);
            
            if (!selectedFacilityId) {
                facilityInfo.style.display = 'none';
                return;
            }
            
            // Find the selected facility data
            const selectedFacility = facilitiesData.find(f => {
                const fId = f.unique_id !== undefined && f.unique_id !== null ? f.unique_id : 
                           (f['CMS Certification Number (CCN)'] || f['CMS Certification Number'] || f.CCN || f.id);
                return String(fId) === String(selectedFacilityId);
            });
            
            console.log('Selected facility:', selectedFacility);
            
            if (selectedFacility) {
                // Display facility information
                infoGrid.innerHTML = '';
                
                // Build fields with the requested mapping and formatting
                const rawZip = selectedFacility['ZIP Code'] || selectedFacility['Zip'] || selectedFacility['ZIP'] || '';
                let zip5 = '';
                if (rawZip !== null && rawZip !== undefined) {
                    const digits = String(rawZip).match(/\d{5}/);
                    zip5 = digits ? digits[0] : String(rawZip).replace(/\D/g, '').slice(0, 5);
                }

                // Get the CCN value properly
                const ccnValue = selectedFacility['CMS Certification Number (CCN)'] || 
                                selectedFacility['CMS Certification Number'] || 
                                selectedFacility['CCN'] || 
                                selectedFacility['ccn'] || 
                                'Not available';
                
                // Debug: Log available column names and county values
                console.log('Available columns in selectedFacility:', Object.keys(selectedFacility));
                console.log('County/Parish value:', selectedFacility['County/Parish']);
                
                // Use County/Parish from provider_info_data (now included by backend)
                const countyValue = (selectedFacility['County/Parish'] && selectedFacility['County/Parish'] !== 'None') ? selectedFacility['County/Parish'] : 'Not available';
                
                console.log('Final county value:', countyValue);
                console.log('County value type:', typeof countyValue);

                // Fetch all historical provider names for this CCN
                let providerNamesDisplay = selectedFacility['Provider Name'] || selectedFacility['provider_name'] || 'Not available';
                try {
                    const namesResponse = await fetch(`/api/provider-names/${ccnValue}`);
                    if (namesResponse.ok) {
                        const namesData = await namesResponse.json();
                        if (namesData.provider_names && namesData.provider_names.length > 0) {
                            if (namesData.provider_names.length === 1) {
                                providerNamesDisplay = namesData.provider_names[0];
                            } else {
                                providerNamesDisplay = namesData.provider_names.join(', ');
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error fetching provider names:', error);
                }

                const fields = [
                    { label: 'CMS Certification Number (CCN)', value: ccnValue },
                    { label: 'Provider Name', value: providerNamesDisplay },
                    { label: 'Address', value: selectedFacility['Provider Address'] || 'Not available' },
                    { label: 'City', value: selectedFacility['City/Town'] || 'Not available' },
                    { label: 'County', value: countyValue },
                    { label: 'State', value: selectedFacility['State'] || selectedFacility['state'] || 'Not available' },
                    { label: 'ZIP Code', value: zip5 || 'Not available' },
                    { label: 'Overall Rating', value: selectedFacility['Overall Rating'] || 'Not available' },
                    { label: 'Number of Certified Beds', value: selectedFacility['Number of Certified Beds'] || 'Not available' },
                    { label: 'Average Number of Residents per Day', value: selectedFacility['Average Number of Residents per Day'] || 'Not available' },
                    { label: 'Health Inspection Rating', value: selectedFacility['Health Inspection Rating'] || 'Not available' },
                    { label: 'Staffing Rating', value: selectedFacility['Staffing Rating'] || 'Not available' }
                ];

                console.log('Fields array:', fields);
                console.log('Number of fields:', fields.length);

                fields.forEach(field => {
                    const infoItem = document.createElement('div');
                    infoItem.className = 'info-item';
                    infoItem.innerHTML = `
                        <div class="info-label">${field.label}</div>
                        <div class="info-value">${field.value}</div>
                    `;
                    infoGrid.appendChild(infoItem);
                });
                
                facilityInfo.style.display = 'block';
                
                // Update the timeline with survey dates
                updateTimeline(selectedFacility);

                // Populate Section 3 timelines
                fetchZipPeerDates(selectedFacility);

                // Populate Section 6 forecasts
                generateForecasts(selectedFacility);

                // Populate Section 7 deficiencies
                fetchDeficiencies(selectedFacility);
                
                // Populate Section 4 histograms
                const state = selectedFacility.State || selectedFacility['State'];
                const county = selectedFacility['County/Parish'] || '';
                const zip = selectedFacility['ZIP Code'] || selectedFacility['Zip'] || '';
                renderCountyHistogram(state, county);
                renderZipHistogram(state, zip);
                
                // Initialize and populate map
                if (!map) {
                    initializeMap();
                }
                const stateSelect = document.getElementById('stateSelect');
                const currentState = stateSelect.value;
                if (currentState) {
                    await loadStateMap(currentState);
                    await loadFacilitiesForMap(currentState);
                    await loadSurveyDataForMap(currentState);
                    // Ensure all historical survey dates for the selected facility are merged into map data
                    await mergeSelectedFacilitySurveysIntoMap(selectedFacility);
                }
            }
        }
        
        function updateTimeline(facility) {
            const timelineContainer = document.getElementById('timelineContainer');
            
            // Clear existing timeline
            timelineContainer.innerHTML = '';
            
            // Create timeline HTML
            const timelineHTML = `
                <div class="timeline">
                    <div class="timeline-line"></div>
                    <div class="timeline-scale">
                        <div class="timeline-scale-item">1/1/2016</div>
                        <div class="timeline-scale-item">1/1/2018</div>
                        <div class="timeline-scale-item">1/1/2020</div>
                        <div class="timeline-scale-item">1/1/2022</div>
                        <div class="timeline-scale-item">7/1/2025</div>
                    </div>
                </div>
                <div class="timeline-info">
                    <h4>Survey Dates for ${facility['Provider Name'] || 'Selected Facility'}</h4>
                    <p>Timeline spans from January 1, 2016 to July 1, 2025</p>
                    <p>Survey dates will be displayed as markers on the timeline</p>
                </div>
            `;
            
            timelineContainer.innerHTML = timelineHTML;
            
            // Fetch survey dates for this facility
            fetchSurveyDates(facility);
        }
        
        async function fetchSurveyDates(facility) {
            try {
                // Get the facility identifier - use unique_id if available, otherwise use CCN
                const facilityId = facility.unique_id !== undefined && facility.unique_id !== null 
                    ? facility.unique_id 
                    : (facility['CMS Certification Number (CCN)'] || facility['CMS Certification Number'] || facility.CCN || facility.id || 0);
                const state = facility.State || facility['State'];
                const facilityName = facility['Provider Name'] || facility['provider_name'] || facility['Facility Name'] || facility['facility_name'] || 'Unknown Facility';
                const ccn = facility['CMS Certification Number (CCN)'] || facility['CMS Certification Number'] || facility.CCN || facility.ccn || '';
                
                if (!state) {
                    console.error('Missing state');
                    return;
                }
                
                console.log(`Fetching survey dates for: ${facilityName} (ID: ${facilityId}, CCN: ${ccn}) in ${state}`);
                
                // Fetch survey dates from the API
                const params = new URLSearchParams();
                if (ccn) params.set('ccn', ccn);
                if (facilityName) params.set('name', facilityName);
                const url = `/api/survey-dates/${encodeURIComponent(state)}/${encodeURIComponent(facilityId)}?${params.toString()}`;
                console.log(`Survey dates API URL: ${url}`);
                const response = await fetch(url);
                if (!response.ok) {
                    let details = '';
                    try {
                        const errData = await response.json();
                        details = errData && errData.error ? `: ${errData.error}` : '';
                    } catch (_) {
                        try {
                            details = `: ${await response.text()}`;
                        } catch (_) {}
                    }
                    throw new Error(`Failed to fetch survey dates (status ${response.status})${details}`);
                }
                
                const data = await response.json();
                console.log('Survey dates data:', data);
                
                // Add markers to the timeline, passing the CCN
                addTimelineMarkers(data.survey_dates, facilityName, state, ccn);
                
            } catch (error) {
                console.error('Error fetching survey dates:', error);
                const timelineContainer = document.getElementById('timelineContainer');
                timelineContainer.innerHTML = `
                    <div class="error">
                        Error loading survey dates: ${error.message}
                    </div>
                `;
            }
        }
        
        async function fetchZipPeerDates(facility) {
            try {
                // Get facility ID - handle unique_id = 0 correctly
                const facilityId = facility.unique_id !== undefined && facility.unique_id !== null 
                    ? facility.unique_id 
                    : (facility['CMS Certification Number (CCN)'] || facility['CMS Certification Number'] || facility.CCN || facility.id || 0);
                const state = facility.State || facility['State'];
                const ccn = facility['CMS Certification Number (CCN)'] || facility['CMS Certification Number'] || facility.CCN || facility.ccn || '';
                const county = facility['County/Parish'] || facility['County'] || '';
                const facilityName = facility['Provider Name'] || facility['provider_name'] || facility['Facility Name'] || facility['facility_name'] || 'Selected Facility';
                
                console.log(`Fetching peer survey dates for: ${facilityName} (ID: ${facilityId}, CCN: ${ccn}, County: ${county}) in ${state}`);
                
                const params = new URLSearchParams();
                if (ccn) params.set('ccn', ccn);
                if (county) params.set('county', county);
                const url = `/api/zip-peer-survey-dates/${encodeURIComponent(state)}/${encodeURIComponent(facilityId)}?${params.toString()}`;
                console.log(`Peer survey dates API URL: ${url}`);
                const response = await fetch(url);
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`Peer survey dates API error (${response.status}):`, errorText);
                    throw new Error(`Failed to fetch county peer dates: ${response.status} ${errorText}`);
                }
                const data = await response.json();
                console.log('Peer survey dates data:', data);
                
                // Get the selected facility's survey dates to include in the timeline
                const facilitySurveyDates = await getSurveyDatesForForecasts(facility);
                
                // Prefer the county from Section 1 if available
                const countyName = county || data.county || 'County';
                
                // Update the timeline header to show the actual county name
                const header = document.getElementById('peerTimelineHeader');
                if (header) {
                    header.textContent = `Timeline 1: ${countyName} County Facilities`;
                }
                
                renderPeerTimeline('zipTimelineContainer', 'zipTimelineInfo', data.survey_dates, countyName, facilitySurveyDates, facilityName);
            } catch (e) {
                const info = document.getElementById('zipTimelineInfo');
                if (info) info.innerHTML = `<div class="error">${e.message}</div>`;
            }
        }

        // Generate forecasts for all six timelines
        async function generateForecasts(facility) {
            try {
                console.log('üîÆ Starting forecast generation for facility:', facility);
                
                // Get facility ID - handle unique_id = 0 correctly
                const facilityId = facility.unique_id !== undefined && facility.unique_id !== null 
                    ? facility.unique_id 
                    : (facility['CMS Certification Number (CCN)'] || facility['CMS Certification Number'] || facility.CCN || facility.id || 0);
                const state = facility.State || facility['State'];
                const ccn = facility['CMS Certification Number (CCN)'] || facility['CMS Certification Number'] || facility.CCN || facility.ccn || '';
                const facilityName = facility['Provider Name'] || facility['provider_name'] || facility['Facility Name'] || facility['facility_name'] || 'Unknown Facility';
                
                console.log('üîÆ Facility details:', { facilityId, state, ccn, facilityName });
                
                // Get historical survey dates using the same method as Section 2
                const surveyDates = await getSurveyDatesForForecasts(facility);
                console.log('üîÆ Survey dates found:', surveyDates);
                
                if (!surveyDates || surveyDates.length === 0) {
                    showForecastError('No historical survey dates found for this facility');
                    return;
                }
                
                const latestDate = new Date(Math.max(...surveyDates.map(d => new Date(d.date))));
                console.log('üîÆ Latest survey date:', latestDate);
                
                // Generate forecasts for each timeline
                console.log('üîÆ Generating forecasts...');
                const forecasts = await Promise.all([
                    generateStateAverageForecast(facility, latestDate),
                    generateZipCodeAverageForecast(facility, latestDate),
                    generateSimilarCharacteristicsForecast(facility, latestDate),
                    generateSimilarDeficienciesForecast(facility, latestDate),
                    generateStateAverage2YearForecast(facility, latestDate),
                    generateCombinedCriteria2YearForecast(facility, latestDate),
                    generateMachineLearningForecast(facility, latestDate)
                ]);
                
                console.log('üîÆ Forecasts generated:', forecasts);
                
                // Cache forecasts for legend/markers on average timeline
                window._latestForecasts = forecasts.filter(f => f && f.date instanceof Date && !isNaN(f.date));

                // Display forecasts on timelines using the same logic as Section 2
                displayForecastsWithHistoricalData(forecasts, surveyDates, facilityName, state);
                
                // Calculate and display average forecast
                const validForecasts = forecasts.filter(f => f && f.date instanceof Date && !isNaN(f.date));
                console.log('üîÆ Valid forecasts:', validForecasts);
                
                if (validForecasts.length > 0) {
                    const averageDate = calculateAverageForecast(validForecasts);
                    console.log('üîÆ Average forecast date:', averageDate);
                    displayAverageForecast(averageDate, surveyDates);
                }
                
            } catch (error) {
                console.error('Error generating forecasts:', error);
                showForecastError('Error generating forecasts: ' + error.message);
            }
        }

        // Generate forecast using backend ML-style endpoint
        async function generateMachineLearningForecast(facility, latestDate) {
            try {
                const state = facility.State || facility['State'];
                const ccn = facility['CMS Certification Number (CCN)'] || facility['CMS Certification Number'] || facility['CCN'] || facility['ccn'] || '';
                const response = await fetch(`/api/ml-forecast`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ state, ccn })
                });
                if (!response.ok) return null;
                const data = await response.json();
                if (!data || !data.forecast_date) return null;
                const forecastDate = roundToNearestMonday(new Date(data.forecast_date));
                if (isNaN(forecastDate)) return null;
                return {
                    type: 'Machine Learning Forecast',
                    date: forecastDate,
                    description: 'Regression-based prediction using historical intervals with county/state fallbacks'
                };
            } catch (e) {
                return null;
            }
        }
        
        // Get survey dates using the same method as Section 2
        async function getSurveyDatesForForecasts(facility) {
            try {
                // Get facility ID - handle unique_id = 0 correctly
                const facilityId = facility.unique_id !== undefined && facility.unique_id !== null 
                    ? facility.unique_id 
                    : (facility['CMS Certification Number (CCN)'] || facility['CMS Certification Number'] || facility.CCN || facility.id || 0);
                const state = facility.State || facility['State'];
                const facilityName = facility['Provider Name'] || facility['provider_name'] || facility['Facility Name'] || facility['facility_name'] || 'Unknown Facility';
                const ccn = facility['CMS Certification Number (CCN)'] || facility['CMS Certification Number'] || facility.CCN || facility.ccn || '';
                
                if (!state) {
                    console.error('Missing state');
                    return [];
                }
                if (facilityId === undefined || facilityId === null) {
                    console.error('Missing facility ID');
                    return [];
                }
                
                console.log(`üîÆ Fetching survey dates for forecasts: ${facilityName} (ID: ${facilityId}, CCN: ${ccn}) in ${state}`);
                
                // Use the same API call as Section 2
                const params = new URLSearchParams();
                if (ccn) params.set('ccn', ccn);
                if (facilityName) params.set('name', facilityName);
                const url = `/api/survey-dates/${encodeURIComponent(state)}/${encodeURIComponent(facilityId)}?${params.toString()}`;
                console.log(`üîÆ Survey dates API URL for forecasts: ${url}`);
                const response = await fetch(url);
                
                if (!response.ok) {
                    let details = '';
                    try {
                        const errData = await response.json();
                        details = errData && errData.error ? `: ${errData.error}` : '';
                    } catch (_) {
                        try {
                            details = `: ${await response.text()}`;
                        } catch (_) {}
                    }
                    throw new Error(`Failed to fetch survey dates (status ${response.status})${details}`);
                }
                
                const data = await response.json();
                console.log('üîÆ Survey dates data for forecasts:', data);
                
                return data.survey_dates || [];
                
            } catch (error) {
                console.error('Error fetching survey dates for forecasts:', error);
                return [];
            }
        }
        
        // Get historical survey dates for a facility
        async function getHistoricalSurveyDates(facility) {
            try {
                const facilityId = facility.unique_id || facility.id || facility.CCN || facility['CMS Certification Number'];
                const state = facility.State || facility['State'];
                const ccn = facility.CCN || facility['CMS Certification Number'] || facility.ccn || '';
                
                const params = new URLSearchParams();
                if (ccn) params.set('ccn', ccn);
                
                const response = await fetch(`/api/facility-survey-dates/${encodeURIComponent(state)}/${encodeURIComponent(facilityId)}?${params.toString()}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch historical survey dates');
                }
                
                const data = await response.json();
                return data.survey_dates || [];
            } catch (error) {
                console.error('Error fetching historical survey dates:', error);
                return [];
            }
        }
        
        // Generate forecast based on state average
        async function generateStateAverageForecast(facility, latestDate) {
            try {
                const state = facility.State || facility['State'];
                const response = await fetch(`/api/state-average-interval/${encodeURIComponent(state)}`);
                if (!response.ok) return null;
                
                const data = await response.json();
                const averageDays = data.average_days || 365; // Default to 1 year
                const forecastDate = new Date(latestDate.getTime() + (averageDays * 24 * 60 * 60 * 1000));
                
                return {
                    type: 'State Average',
                    date: roundToNearestMonday(forecastDate),
                    description: `Based on state average of ${averageDays} days between surveys`
                };
            } catch (error) {
                console.error('Error generating state average forecast:', error);
                return null;
            }
        }
        
        // Generate forecast based on County/Parish average
        async function generateZipCodeAverageForecast(facility, latestDate) {
            try {
                const state = facility.State || facility['State'];
                const county = facility['County/Parish'] || '';
                console.log('Timeline 2 - County/Parish:', county);
                if (!county) {
                    console.error('Timeline 2 - No county/parish found for facility');
                    return null;
                }
                const response = await fetch(`/api/zip-average-interval/${encodeURIComponent(state)}/${encodeURIComponent(county)}`);
                if (!response.ok) {
                    console.error('Timeline 2 - API error:', response.status, response.statusText);
                    return null;
                }
                
                const data = await response.json();
                const averageDays = data.average_days || 365;
                const forecastDate = new Date(latestDate.getTime() + (averageDays * 24 * 60 * 60 * 1000));
                
                return {
                    type: 'County Average',
                    date: roundToNearestMonday(forecastDate),
                    description: `Based on county average of ${averageDays} days between surveys`
                };
            } catch (error) {
                console.error('Error generating ZIP code average forecast:', error);
                return null;
            }
        }
        
        // Generate forecast based on similar characteristics
        async function generateSimilarCharacteristicsForecast(facility, latestDate) {
            try {
                const state = facility.State || facility['State'];
                const response = await fetch(`/api/similar-characteristics-interval/${encodeURIComponent(state)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(facility)
                });
                if (!response.ok) return null;
                
                const data = await response.json();
                const averageDays = data.average_days || 365;
                const forecastDate = new Date(latestDate.getTime() + (averageDays * 24 * 60 * 60 * 1000));
                
                return {
                    type: 'Similar Characteristics',
                    date: roundToNearestMonday(forecastDate),
                    description: `Based on similar facilities average of ${averageDays} days between surveys`
                };
            } catch (error) {
                console.error('Error generating similar characteristics forecast:', error);
                return null;
            }
        }
        
        // Generate forecast based on similar deficiencies
        async function generateSimilarDeficienciesForecast(facility, latestDate) {
            try {
                const state = facility.State || facility['State'];
                const response = await fetch(`/api/similar-deficiencies-interval/${encodeURIComponent(state)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(facility)
                });
                if (!response.ok) return null;
                
                const data = await response.json();
                const averageDays = data.average_days || 365;
                const forecastDate = new Date(latestDate.getTime() + (averageDays * 24 * 60 * 60 * 1000));
                
                return {
                    type: 'Similar Deficiencies',
                    date: roundToNearestMonday(forecastDate),
                    description: `Based on similar deficiency patterns average of ${averageDays} days between surveys`
                };
            } catch (error) {
                console.error('Error generating similar deficiencies forecast:', error);
                return null;
            }
        }
        
        // Generate forecast based on state average over past 2 years
        async function generateStateAverage2YearForecast(facility, latestDate) {
            try {
                const state = facility.State || facility['State'];
                const response = await fetch(`/api/state-average-2year-interval/${encodeURIComponent(state)}`);
                if (!response.ok) return null;
                
                const data = await response.json();
                const averageDays = data.average_days || 365;
                const forecastDate = new Date(latestDate.getTime() + (averageDays * 24 * 60 * 60 * 1000));
                
                return {
                    type: 'State Average (2 Years)',
                    date: roundToNearestMonday(forecastDate),
                    description: `Based on state average over past 2 years: ${averageDays} days between surveys`
                };
            } catch (error) {
                console.error('Error generating state average 2-year forecast:', error);
                return null;
            }
        }
        
        // Generate forecast based on combined criteria over past 2 years
        async function generateCombinedCriteria2YearForecast(facility, latestDate) {
            try {
                const state = facility.State || facility['State'];
                const response = await fetch(`/api/combined-criteria-2year-interval/${encodeURIComponent(state)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(facility)
                });
                if (!response.ok) return null;
                
                const data = await response.json();
                const averageDays = data.average_days || 365;
                const forecastDate = new Date(latestDate.getTime() + (averageDays * 24 * 60 * 60 * 1000));
                
                return {
                    type: 'Combined Criteria (2 Years)',
                    date: roundToNearestMonday(forecastDate),
                    description: `Based on combined criteria over past 2 years: ${averageDays} days between surveys`
                };
            } catch (error) {
                console.error('Error generating combined criteria 2-year forecast:', error);
                return null;
            }
        }
        
        // Display forecasts on timelines using the same logic as Section 2
        function displayForecastsWithHistoricalData(forecasts, surveyDates, facilityName, state) {
            const timelineContainers = [
                'forecastTimeline1Info', 'forecastTimeline2Info', 'forecastTimeline3Info',
                'forecastTimeline4Info', 'forecastTimeline5Info', 'forecastTimeline6Info',
                'forecastTimeline7Info'
            ];
            
            console.log('üîÆ Displaying forecasts with historical data:', { surveyDates, facilityName, state });
            
            // Add historical markers to all timelines using the same logic as Section 2
            addHistoricalMarkersToAllForecastTimelines(surveyDates, facilityName, state);
            
            forecasts.forEach((forecast, index) => {
                const container = document.getElementById(timelineContainers[index]);
                if (!container) return;
                
                const isValidDate = forecast && forecast.date instanceof Date && !isNaN(forecast.date);
                if (isValidDate) {
                    container.innerHTML = `
                        <h4>${forecast.type}</h4>
                        <p><strong>Predicted Date:</strong> ${forecast.date.toLocaleDateString()}</p>
                        <p>${forecast.description}</p>
                    `;
                    
                    // Add forecast marker to timeline
                    addForecastMarkerToTimeline(index, forecast.date);
                } else {
                    container.innerHTML = `<p>Unable to generate forecast for this timeline.</p>`;
                }
            });
        }
        
        // Add historical markers to all forecast timelines using Section 2 logic
        function addHistoricalMarkersToAllForecastTimelines(surveyDates, facilityName, state) {
            console.log('üîÆ Adding historical markers to all forecast timelines:', surveyDates);
            
            const timelineContainers = [
                'forecastTimeline1Info', 'forecastTimeline2Info', 'forecastTimeline3Info',
                'forecastTimeline4Info', 'forecastTimeline5Info', 'forecastTimeline6Info',
                'forecastTimeline7Info'
            ];
            
            timelineContainers.forEach((containerId, index) => {
                const container = document.getElementById(containerId);
                if (!container) {
                    console.log(`üîÆ Container not found: ${containerId}`);
                    return;
                }
                
                const timeline = container.previousElementSibling;
                if (!timeline || !timeline.classList.contains('timeline')) {
                    console.log(`üîÆ Timeline not found for ${containerId}:`, timeline);
                    return;
                }
                
                console.log(`üîÆ Adding historical markers to timeline ${index + 1}`);
                
                // Clear existing markers first
                const existingMarkers = timeline.querySelectorAll('.timeline-marker, .forecast-marker');
                existingMarkers.forEach(marker => marker.remove());
                
                // Add historical markers using the exact same logic as Section 2
                surveyDates.forEach((dateInfo) => {
                    addHistoricalMarkerToForecastTimeline(timeline, dateInfo);
                });
            });
        }
        
        // Add a historical marker to a forecast timeline using Section 2 logic
        function addHistoricalMarkerToForecastTimeline(timeline, dateInfo) {
            // Calculate position on timeline (1/1/2016 to 12/31/2026) - extended for forecasts
            const startDate = new Date('2016-01-01');
            const endDate = new Date('2027-12-31');
            const surveyDate = new Date(dateInfo.date);
            
            const totalDays = (endDate - startDate) / (1000 * 60 * 60 * 24);
            const daysFromStart = (surveyDate - startDate) / (1000 * 60 * 60 * 24);
            const position = (daysFromStart / totalDays) * 100;
            
            // Create historical marker using the same structure as Section 2
            const marker = document.createElement('div');
            marker.className = 'timeline-marker';
            marker.title = `Survey Date: ${dateInfo.date}`;
            marker.style.left = `${Math.max(0, Math.min(100, position))}%`;
            
            // Add date label using the same format as Section 2
            const dateLabel = document.createElement('div');
            dateLabel.className = 'timeline-date';
            dateLabel.textContent = new Date(dateInfo.date).toLocaleDateString();
            marker.appendChild(dateLabel);
            
            // Add click event for marker details (same as Section 2)
            marker.addEventListener('click', () => {
                showMarkerDetails(dateInfo, marker);
            });
            
            timeline.appendChild(marker);
        }
        
        // Add forecast marker to a specific timeline
        function addForecastMarkerToTimeline(timelineIndex, forecastDate) {
            console.log(`üîÆ Adding forecast marker to timeline ${timelineIndex + 1}:`, forecastDate);
            
            const timelineContainers = [
                'forecastTimeline1Info', 'forecastTimeline2Info', 'forecastTimeline3Info',
                'forecastTimeline4Info', 'forecastTimeline5Info', 'forecastTimeline6Info',
                'forecastTimeline7Info'
            ];
            
            const container = document.getElementById(timelineContainers[timelineIndex]);
            if (!container) {
                console.log(`üîÆ Container not found for timeline ${timelineIndex + 1}: ${timelineContainers[timelineIndex]}`);
                return;
            }
            
            const timeline = container.previousElementSibling;
            if (!timeline || !timeline.classList.contains('timeline')) {
                console.log(`üîÆ Timeline not found for timeline ${timelineIndex + 1}:`, timeline);
                return;
            }
            
            // Calculate position on timeline (1/1/2016 to 12/31/2026) - extended for forecasts
            const startDate = new Date('2016-01-01');
            const endDate = new Date('2027-12-31');
            const totalDays = (endDate - startDate) / (1000 * 60 * 60 * 24);
            const daysFromStart = (forecastDate - startDate) / (1000 * 60 * 60 * 24);
            const position = Math.max(0, Math.min(100, (daysFromStart / totalDays) * 100));
            
            console.log(`üîÆ Forecast position calculated: ${position}%`);
            
            // Create forecast marker
            const marker = document.createElement('div');
            marker.className = 'forecast-marker';
            marker.style.left = `${position}%`;
            if (forecastDate && !isNaN(forecastDate)) {
                marker.title = `Forecast: ${forecastDate.toLocaleDateString()}`;
            } else {
                marker.title = 'Forecast';
            }
            timeline.appendChild(marker);
            
            console.log(`üîÆ Forecast marker added to timeline ${timelineIndex + 1}`);
        }
        
        
        // Round a date to the nearest Monday
        function roundToNearestMonday(date) {
            const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            const daysToAdd = dayOfWeek === 0 ? 1 : (dayOfWeek <= 4 ? (1 - dayOfWeek) : (8 - dayOfWeek));
            const monday = new Date(date);
            monday.setDate(date.getDate() + daysToAdd);
            return monday;
        }
        
        // Calculate average forecast date
        function calculateAverageForecast(forecasts) {
            if (forecasts.length === 0) return null;
            
            const totalTime = forecasts.reduce((sum, forecast) => sum + forecast.date.getTime(), 0);
            const averageTime = totalTime / forecasts.length;
            const averageDate = new Date(averageTime);
            return roundToNearestMonday(averageDate);
        }
        
        // Display average forecast
        function displayAverageForecast(averageDate, surveyDates) {
            const valueElement = document.getElementById('averageForecastValue');
            const calendarInput = document.getElementById('customDateInput');
            
            if (valueElement && averageDate) {
                valueElement.textContent = averageDate.toLocaleDateString();
            }
            
            // Set the calendar input to the average forecast date as default
            if (calendarInput && averageDate) {
                // Ensure min date is set first
                setDateInputMin();
                // Format date as YYYY-MM-DD for the date input
                const year = averageDate.getFullYear();
                const month = String(averageDate.getMonth() + 1).padStart(2, '0');
                const day = String(averageDate.getDate()).padStart(2, '0');
                const dateStr = `${year}-${month}-${day}`;
                // Only set if date is not before today
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const selectedDate = new Date(dateStr);
                selectedDate.setHours(0, 0, 0, 0);
                if (selectedDate >= today) {
                    calendarInput.value = dateStr;
                } else {
                    const todayStr = today.toISOString().split('T')[0];
                    calendarInput.value = todayStr;
                }
            }
            
            // Populate the average forecast timeline with historical dates and forecast
            populateAverageForecastTimeline(surveyDates, averageDate);
        }
        
        // Populate the average forecast timeline
        function populateAverageForecastTimeline(surveyDates, forecastDate) {
            const timeline = document.querySelector('#averageForecastDisplay').previousElementSibling.querySelector('.timeline');
            const infoDiv = document.getElementById('averageForecastTimelineInfo');
            const legendContainerId = 'averageForecastLegend';
            
            if (!timeline || !surveyDates || surveyDates.length === 0) return;
            
            // Clear existing markers
            timeline.querySelectorAll('.timeline-marker').forEach(m => m.remove());
            
            const startDate = new Date('2016-01-01');
            const endDate = new Date('2027-12-31');
            const totalDays = (endDate - startDate) / (1000 * 60 * 60 * 24);
            
            // Add historical survey dates in green
            surveyDates.forEach(dateInfo => {
                const date = new Date(dateInfo.date);
                const daysSinceStart = (date - startDate) / (1000 * 60 * 60 * 24);
                const position = (daysSinceStart / totalDays) * 100;
                
                const marker = document.createElement('div');
                marker.className = 'timeline-marker historical-marker';
                marker.style.left = `${position}%`;
                marker.style.backgroundColor = '#10b981'; // green
                marker.title = `Historical Survey: ${date.toLocaleDateString()}`;
                
                const label = document.createElement('div');
                label.className = 'timeline-date';
                label.textContent = date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                marker.appendChild(label);
                
                timeline.appendChild(marker);
            });
            
            // Add average forecast date in red
            if (forecastDate) {
                const daysSinceStart = (forecastDate - startDate) / (1000 * 60 * 60 * 24);
                const position = (daysSinceStart / totalDays) * 100;
                
                const marker = document.createElement('div');
                marker.className = 'timeline-marker forecast-marker';
                marker.style.left = `${position}%`;
                marker.style.backgroundColor = '#ef4444'; // red
                marker.style.fontSize = '18px';
                marker.innerHTML = 'üîÆ';
                marker.title = `Average Forecast: ${forecastDate.toLocaleDateString()}`;
                
                const label = document.createElement('div');
                label.className = 'timeline-date';
                label.textContent = forecastDate.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                marker.appendChild(label);
                
                timeline.appendChild(marker);
            }
            
            // Add seven forecast markers (State Avg, County Avg, Similar Characteristics, Similar Deficiencies, State Avg 2Y, Combined 2Y, ML)
            const forecastTypes = [
                { id: 'state', label: 'State Average', color: '#1f77b4' },
                { id: 'county', label: 'County Average', color: '#ff7f0e' },
                { id: 'similarChar', label: 'Similar Characteristics', color: '#2ca02c' },
                { id: 'similarDef', label: 'Similar Deficiencies', color: '#d62728' },
                { id: 'state2y', label: 'State Avg (2Y)', color: '#9467bd' },
                { id: 'combined2y', label: 'Combined (2Y)', color: '#8c564b' },
                { id: 'ml', label: 'Machine Learning', color: '#e377c2' }
            ];
            const forecastsCache = window._latestForecasts || [];
            forecastsCache.forEach((f, idx) => {
                if (!f || !(f.date instanceof Date) || isNaN(f.date)) return;
                const daysSinceStart = (f.date - startDate) / (1000 * 60 * 60 * 24);
                const position = (daysSinceStart / totalDays) * 100;
                const fm = document.createElement('div');
                fm.className = `timeline-marker forecast-type-marker forecast-${forecastTypes[idx]?.id || 'x'}`;
                fm.style.left = `${position}%`;
                fm.style.backgroundColor = forecastTypes[idx]?.color || '#333';
                fm.title = `${f.type}: ${f.date.toLocaleDateString()}`;
                timeline.appendChild(fm);
            });

            // Build legend below timeline
            const container = document.querySelector('#averageForecastDisplay').previousElementSibling;
            let legend = document.getElementById(legendContainerId);
            if (!legend) {
                legend = document.createElement('div');
                legend.id = legendContainerId;
                legend.style.marginTop = '8px';
                legend.style.display = 'flex';
                legend.style.flexWrap = 'wrap';
                legend.style.gap = '10px';
                container.appendChild(legend);
            }
            legend.innerHTML = '';
            forecastTypes.forEach((ft, idx) => {
                const item = document.createElement('button');
                item.type = 'button';
                item.textContent = ft.label;
                item.style.padding = '4px 8px';
                item.style.border = '1px solid #ddd';
                item.style.borderRadius = '4px';
                item.style.cursor = 'pointer';
                item.style.background = '#fff';
                item.style.display = 'inline-flex';
                item.style.alignItems = 'center';
                item.style.gap = '6px';
                const swatch = document.createElement('span');
                swatch.style.display = 'inline-block';
                swatch.style.width = '10px';
                swatch.style.height = '10px';
                swatch.style.background = ft.color;
                swatch.style.borderRadius = '2px';
                item.prepend(swatch);
                item.addEventListener('click', () => {
                    // highlight corresponding forecast marker
                    timeline.querySelectorAll('.forecast-type-marker').forEach(el => {
                        el.style.transform = 'scale(1)';
                        el.style.boxShadow = 'none';
                    });
                    const target = timeline.querySelector(`.forecast-${ft.id}`);
                    if (target) {
                        target.style.transform = 'scale(1.4)';
                        target.style.boxShadow = '0 0 8px rgba(0,0,0,0.3)';
                    }
                });
                legend.appendChild(item);
            });

            // Update info text
            if (infoDiv) {
                infoDiv.innerHTML = `<p>Historical surveys: ${surveyDates.length} | Average forecast: ${forecastDate ? forecastDate.toLocaleDateString() : 'N/A'}</p>`;
            }
        }
        
        // Show forecast error
        function showForecastError(message) {
            const timelineContainers = [
                'forecastTimeline1Info', 'forecastTimeline2Info', 'forecastTimeline3Info',
                'forecastTimeline4Info', 'forecastTimeline5Info', 'forecastTimeline6Info'
            ];
            
            timelineContainers.forEach(containerId => {
                const container = document.getElementById(containerId);
                if (container) {
                    container.innerHTML = `<div class="error">${message}</div>`;
                }
            });
        }
        
        /* ============================================================
           REQUIRED: SECTION 6 DATE VALIDATION - DO NOT DELETE
           Prevents selecting dates before today and sets min attribute.
           ============================================================ */
        function setDateInputMin() {
            const customDateInput = document.getElementById('customDateInput');
            if (customDateInput) {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const minDateStr = today.toISOString().split('T')[0];
                customDateInput.setAttribute('min', minDateStr);
                customDateInput.addEventListener('change', function() {
                    const selectedDate = new Date(this.value);
                    selectedDate.setHours(0, 0, 0, 0);
                    if (selectedDate < today) {
                        alert('Please select a date that is not before the current date.');
                        this.value = minDateStr;
                    }
                });
            }
        }
        /* ============================================================ */
        
        /* ============================================================
           REQUIRED: SECTION 8 DYNAMIC PROMPT GENERATION - DO NOT DELETE
           Validates date and dynamically adjusts prompt based on time available.
           ============================================================ */
        function generatePrompt() {
            const customDateInput = document.getElementById('customDateInput');
            const selectedDate = customDateInput.value;
            
            if (!selectedDate) {
                alert('Please select a date before generating a prompt.');
                return;
            }
            
            // Validate date is not before today
            const selectedDateObj = new Date(selectedDate);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const selectedDateNormalized = new Date(selectedDateObj);
            selectedDateNormalized.setHours(0, 0, 0, 0);
            if (isNaN(selectedDateObj) || selectedDateNormalized < today) {
                alert('Please select a date that is not before the current date.');
                return;
            }
            
            // Gather context
            const stateSelect = document.getElementById('stateSelect');
            const stateCode = stateSelect ? (stateSelect.value || '') : '';
            const stateDisplay = stateCode || 'Selected State';
            
            const facilitySelect = document.getElementById('facilitySelect');
            const selectedFacilityId = facilitySelect ? facilitySelect.value : '';
            let facilityName = '';
            if (selectedFacilityId && Array.isArray(facilitiesData)) {
                const fac = facilitiesData.find(f => (
                    f.unique_id || f.id || f.CCN || f['CMS Certification Number'] || f['CMS Certification Number (CCN)']
                ) == selectedFacilityId);
                if (fac) {
                    facilityName = fac['Provider Name'] || fac['provider_name'] || fac['Facility Name'] || fac['facility_name'] || fac['Name'] || fac['name'] || '';
                }
            }
            const facilityDisplay = facilityName || 'Selected Facility';
            
            const trends = window._lastDefTrends || {};
            const zipTrendsHtml = trends.zipTrendsHtml || '';
            const zipSummary = trends.zipSummary || '';
            const countyTrendsHtml = trends.countyTrendsHtml || '';
            const countySummaryHtml = trends.countySummaryHtml || '';
            const stateTrendsHtml = trends.stateTrendsHtml || '';
            const stateSummaryHtml = trends.stateSummaryHtml || '';
            
            const stripHtml = (html) => (html || '').replace(/<[^>]+>/g, '').replace(/\s+\n/g, '\n').trim();
            const zipTrendsText = stripHtml(zipTrendsHtml);
            const countyTrendsText = stripHtml(countyTrendsHtml);
            const countySummaryText = stripHtml(countySummaryHtml);
            const stateTrendsText = stripHtml(stateTrendsHtml);
            const stateSummaryText = stripHtml(stateSummaryHtml);
            
            const selectedDateDisplay = isNaN(selectedDateObj) ? selectedDate : selectedDateObj.toLocaleDateString();
            
            // Calculate time difference for dynamic schedule blocks
            const daysDifference = Math.ceil((selectedDateNormalized - today) / (1000 * 60 * 60 * 24));
            const weeksDifference = Math.floor(daysDifference / 7);
            const monthsDifference = Math.floor(daysDifference / 30);
            
            let timePeriodDescription = '';
            let scheduleBlocks = [];
            
            if (daysDifference <= 14) {
                timePeriodDescription = '1-2 weeks';
                scheduleBlocks = ['7 days before', '3 days before', '1 day before', 'Daily until survey']
                    .map(p => `- ${p}: [Add facility-specific preparation activities here]`).join('\n');
            } else if (daysDifference <= 60) {
                timePeriodDescription = '2-6 weeks';
                scheduleBlocks = ['30 days before', '14 days before', '7 days before', '3 days before', 'Daily until survey']
                    .map(p => `- ${p}: [Add facility-specific preparation activities here]`).join('\n');
            } else if (daysDifference <= 180) {
                timePeriodDescription = '2-6 months';
                scheduleBlocks = ['60 days before', '30 days before', '14 days before', '7 days before', 'Daily until survey']
                    .map(p => `- ${p}: [Add facility-specific preparation activities here]`).join('\n');
            } else {
                timePeriodDescription = '6+ months';
                scheduleBlocks = ['90 days before', '60 days before', '30 days before', '14 days before', '7 days before', 'Daily until survey']
                    .map(p => `- ${p}: [Add facility-specific preparation activities here]`).join('\n');
            }
            
            const relevantDocs = [
                'CMS State Operations Manual (Appendix PP) ‚Äì F-Tags and Guidance',
                'Prior CMS-2567 Statements of Deficiencies (facility)',
                'Plan of Correction(s) and follow-up evidence',
                'Quality Assurance & Performance Improvement (QAPI) meeting minutes',
                'Infection Prevention & Control Program documentation',
                'Staff competency and in-service training records',
                'Resident council and grievance logs',
                'Medication administration and pharmacy consultant reports',
                'Life Safety Code inspection reports (if relevant)'
            ].map(d => `- ${d}`).join('\n');
            
            // Get additional information from textarea
            const additionalInfoTextarea = document.getElementById('AdditionalInfo');
            const additionalInfo = additionalInfoTextarea ? (additionalInfoTextarea.value || '').trim() : '';
            const additionalInfoSection = additionalInfo ? `\n\nAdditional facility information and considerations:\n${additionalInfo}\n` : '';
            
            const prompt = `You are an assistant helping prepare the skilled nursing facility "${facilityDisplay}" in ${stateDisplay} for an upcoming health survey.\n\nExpected health survey date: ${selectedDateDisplay}.\nTime available for preparation: ${timePeriodDescription} (${daysDifference} days).${additionalInfoSection}\nObserved trends and context to incorporate into the preparation plan:\n\nCounty-level trends (frequency):\n${countyTrendsText || '[No county trends available]'}\n\nCounty trend summary:\n${countySummaryText || '[No county trend summary available]'}\n\nZIP-level trends (frequency):\n${zipTrendsText || '[No ZIP trends available]'}\n\nZIP trend summary:\n${zipSummary || '[No ZIP trend summary available]'}\n\nState-level trends (frequency):\n${stateTrendsText || '[No state trends available]'}\n\nState trend summary:\n${stateSummaryText || '[No state trend summary available]'}\n\nThe preparation schedule should reference and leverage the following documents if available:\n${relevantDocs}\n\nCreate a practical preparation schedule with checklists and owners for these intervals relative to the expected survey date:\n${scheduleBlocks}\n\nIMPORTANT: At the end of your response, provide a valid JSON string that can be directly imported into ToDoIst. Format it as a fenced code block like this:\n\n\`\`\`json\n[\n  {\n    "content": "Task description",\n    "due_string": "2024-01-15",\n    "priority": 1\n  }\n]\n\`\`\`\n\nThe JSON should contain an array of task objects, each with at least a "content" field. Include due dates mapped to the preparation intervals based on the time available (${timePeriodDescription}).\n\nEnsure the plan prioritizes high-risk, high-frequency tags in ${stateDisplay}, incorporates recent deficiency patterns from county and state data, and is realistic for nursing, social services, dietary, maintenance, infection control, and administration. Provide clear deliverables and verification steps for each period.`;
            
            // Populate Section 8
            const section8 = document.getElementById('promptSection');
            const textarea = document.getElementById('promptTextarea');
            if (section8) section8.style.display = 'block';
            if (textarea) {
                textarea.value = prompt;
                textarea.focus();
            }
            
            // Scroll to Section 8
            if (section8 && section8.scrollIntoView) section8.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        async function renderStateHistogram(state) {
            try {
                const container = document.getElementById('histogramContainer');
                if (!container) {
                    console.error('histogramContainer not found');
                    return;
                }
                container.innerHTML = '<div class="loading">Loading monthly survey counts...</div>';
                console.log(`Fetching state monthly surveys for: ${state}`);
                const res = await fetch(`/api/state-monthly-surveys/${encodeURIComponent(state)}`);
                if (!res.ok) {
                    const errorText = await res.text();
                    console.error(`API error (${res.status}):`, errorText);
                    throw new Error(`Failed to fetch state monthly histogram: ${res.status} ${errorText}`);
                }
                const data = await res.json();
                console.log('State monthly surveys data:', data);
                if (data.error) {
                    throw new Error(data.error);
                }
                drawHistogram(container, data.buckets || []);
            } catch (e) {
                console.error('Error in renderStateHistogram:', e);
                const container = document.getElementById('histogramContainer');
                if (container) {
                    container.innerHTML = `<div class="error">${e.message}</div>`;
                }
            }
        }
        
        async function renderCountyHistogram(state, county) {
            try {
                const container = document.getElementById('countyHistogramContainer');
                if (!county) {
                    container.innerHTML = '<div class="placeholder">Select a facility to view county survey counts</div>';
                    return;
                }
                container.innerHTML = '<div class="loading">Loading county monthly survey counts...</div>';
                const res = await fetch(`/api/county-monthly-surveys/${encodeURIComponent(state)}/${encodeURIComponent(county)}`);
                if (!res.ok) {
                    throw new Error('Failed to fetch county monthly histogram');
                }
                const data = await res.json();
                drawHistogram(container, data.buckets || []);
            } catch (e) {
                const container = document.getElementById('countyHistogramContainer');
                container.innerHTML = `<div class="error">${e.message}</div>`;
            }
        }
        
        async function renderZipHistogram(state, zip) {
            try {
                const container = document.getElementById('zipHistogramContainer');
                if (!zip) {
                    container.innerHTML = '<div class="placeholder">Select a facility to view ZIP survey counts</div>';
                    return;
                }
                container.innerHTML = '<div class="loading">Loading ZIP monthly survey counts...</div>';
                const res = await fetch(`/api/zip-monthly-surveys/${encodeURIComponent(state)}/${encodeURIComponent(zip)}`);
                if (!res.ok) {
                    throw new Error('Failed to fetch ZIP monthly histogram');
                }
                const data = await res.json();
                drawHistogram(container, data.buckets || []);
            } catch (e) {
                const container = document.getElementById('zipHistogramContainer');
                container.innerHTML = `<div class="error">${e.message}</div>`;
            }
        }

        function drawHistogram(container, buckets) {
            if (!buckets || buckets.length === 0) {
                container.innerHTML = '<div class="placeholder">No survey dates found in this period for the selected state.</div>';
                return;
            }
            // Ensure 12 calendar months in order
            const monthOrder = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
            const byLabel = Object.fromEntries((buckets || []).map(b => [b.label, b.count]));
            const ordered = monthOrder.map(lbl => ({ label: lbl, count: byLabel[lbl] || 0 }));
            const maxCount = Math.max(...ordered.map(b => b.count));
            const barsHtml = ordered.map(b => {
                const h = maxCount > 0 ? Math.round((b.count / maxCount) * 200) : 0;
                return `<div class=\"hist-bar\" title=\"${b.label}: ${b.count}\" style=\"height:${h}px\"></div>`;
            }).join('');
            const axisHtml = ordered.map(b => `<span>${b.label}</span>`).join('');
            container.innerHTML = `
                <div class="histogram">
                    <div class="hist-bars">${barsHtml}</div>
                </div>
                <div class="hist-axis">${axisHtml}</div>
            `;
        }

        function renderPeerTimeline(containerId, infoId, surveyDates, label, facilitySurveyDates = null, facilityName = 'Selected Facility') {
            const container = document.getElementById(containerId);
            const timeline = container.querySelector('.timeline');
            const info = document.getElementById(infoId);
            
            // Update timeline scale end date to 15 months from today
            const today = new Date();
            const endDate15Months = new Date(today);
            endDate15Months.setMonth(today.getMonth() + 15);
            const scaleEndDateElement = container.querySelector('#peerTimelineEndDate') || document.getElementById('peerTimelineEndDate');
            if (scaleEndDateElement) {
                const month = endDate15Months.getMonth() + 1;
                const year = endDate15Months.getFullYear();
                scaleEndDateElement.textContent = `${month}/1/${year}`;
            }
            
            // Clear existing markers
            timeline.querySelectorAll('.timeline-marker').forEach(el => el.remove());
            
            // Combine peer survey dates with facility survey dates
            let allSurveyDates = surveyDates || [];
            if (facilitySurveyDates && facilitySurveyDates.length > 0) {
                // Add facility survey dates with a special marker to distinguish them
                const facilityDates = facilitySurveyDates.map(dateInfo => ({
                    ...dateInfo,
                    facility_name: facilityName,
                    ccn: 'SELECTED',
                    is_selected_facility: true
                }));
                allSurveyDates = [...facilityDates, ...allSurveyDates];
            }
            
            if (allSurveyDates.length === 0) {
                info.innerHTML = `<h4>No peer survey dates found (${label}).</h4>`;
                return;
            }

            // Group by facility (name + CCN)
            const groups = {};
            allSurveyDates.forEach(d => {
                const key = `${d.facility_name || 'N/A'}|${d.ccn || ''}`;
                if (!groups[key]) groups[key] = { name: d.facility_name || 'N/A', ccn: d.ccn || '', items: [], is_selected_facility: d.is_selected_facility || false };
                groups[key].items.push(d);
            });

            // Assign colors per facility
            const palette = [
                '#667eea','#f56565','#48bb78','#ed8936','#38b2ac','#9f7aea','#F59E0B','#10B981',
                '#3B82F6','#EF4444','#8B5CF6','#14B8A6','#84CC16','#EC4899'
            ];
            const keys = Object.keys(groups);
            const keyToColor = {};
            keys.forEach((k, i) => { keyToColor[k] = palette[i % palette.length]; });

            // Legend and dates list grouped by facility
            let legendHtml = '<div style="margin-top:8px"><strong>Legend (click to highlight):</strong><ul style="list-style:none;padding-left:0">';
            let datesList = '';
            keys.forEach(k => {
                const g = groups[k];
                const color = keyToColor[k];
                legendHtml += `<li class="legend-item" data-key="${k}"><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${color};margin-right:6px;vertical-align:middle"></span>${g.name}${g.ccn ? ` (CCN ${g.ccn})` : ''}</li>`;
                const sub = g.items
                    .sort((a,b) => new Date(a.date) - new Date(b.date))
                    .map(d => `<li>${new Date(d.date).toLocaleDateString()}</li>`)
                    .join('');
                datesList += `<li><strong>${g.name}${g.ccn ? ` (CCN ${g.ccn})` : ''}</strong><ul>${sub}</ul></li>`;
            });
            legendHtml += '</ul></div>';

            info.innerHTML = `
                <h4>Peer Survey Dates (${label}): ${allSurveyDates.length}</h4>
                ${legendHtml}
                <div style="margin-top:15px;">
                    <button id="toggleDetailsBtn" style="padding: 6px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9rem; font-weight: 600;">
                        ‚ñº Hide Details
                    </button>
                </div>
                <div id="facilityDetailsContainer" style="margin-top:8px">
                    <ul>${datesList}</ul>
                </div>
            `;
            
            // Add toggle functionality
            const toggleBtn = info.querySelector('#toggleDetailsBtn');
            const detailsContainer = info.querySelector('#facilityDetailsContainer');
            
            if (toggleBtn && detailsContainer) {
                toggleBtn.addEventListener('click', function() {
                    const isVisible = detailsContainer.style.display !== 'none';
                    if (isVisible) {
                        detailsContainer.style.display = 'none';
                        this.textContent = '‚ñ∂ Show Details';
                    } else {
                        detailsContainer.style.display = 'block';
                        this.textContent = '‚ñº Hide Details';
                    }
                });
            }

            // Plot markers colored by facility
            const startDate = new Date('2016-01-01');
            // Calculate end date as 15 months from today (reuse today from above)
            const endDate = new Date(today);
            endDate.setMonth(today.getMonth() + 15);
            const totalDays = (endDate - startDate) / (1000 * 60 * 60 * 24);

            // Group markers by position to detect overlaps
            const positionGroups = new Map();
            
            allSurveyDates.forEach(d => {
                const key = `${d.facility_name || 'N/A'}|${d.ccn || ''}`;
                const color = keyToColor[key] || '#667eea';
                const marker = document.createElement('div');
                marker.className = 'timeline-marker';
                marker.style.background = color;
                
                // Make selected facility markers larger and add special styling
                if (d.is_selected_facility) {
                    marker.style.width = '16px';
                    marker.style.height = '16px';
                    marker.style.border = '3px solid #2d3748';
                    marker.style.boxShadow = '0 0 8px rgba(45, 55, 72, 0.6)';
                    marker.title = `SELECTED FACILITY: ${d.facility_name || ''} ‚Äî ${new Date(d.date).toLocaleDateString()}`;
                    marker.dataset.isSelected = 'true'; // Add data attribute to identify selected facility
                } else {
                marker.title = `${d.facility_name || ''} ‚Äî ${new Date(d.date).toLocaleDateString()}`;
                }
                
                marker.dataset.key = key;
                const surveyDate = new Date(d.date);
                const daysFromStart = (surveyDate - startDate) / (1000 * 60 * 60 * 24);
                const position = (daysFromStart / totalDays) * 100;
                marker.style.left = `${Math.max(0, Math.min(100, position))}%`;
                
                // Round position to nearest 1% to group nearby markers
                const roundedPosition = Math.round(position);
                if (!positionGroups.has(roundedPosition)) {
                    positionGroups.set(roundedPosition, []);
                }
                positionGroups.get(roundedPosition).push(marker);
                
                // Format date as month/year only
                const dateLabel = document.createElement('div');
                dateLabel.className = 'timeline-date';
                const surveyDateObj = new Date(d.date);
                const monthYear = surveyDateObj.toLocaleDateString('en-US', { 
                    month: 'short', 
                    year: 'numeric' 
                });
                dateLabel.textContent = monthYear;
                marker.appendChild(dateLabel);
                timeline.appendChild(marker);
            });
            
            // Apply staggered positioning to overlapping markers
            positionGroups.forEach(markers => {
                if (markers.length > 1) {
                    markers.forEach((marker, index) => {
                        const dateLabel = marker.querySelector('.timeline-date');
                        if (index === 0) {
                            dateLabel.classList.add('staggered');
                        } else if (index === 1) {
                            dateLabel.classList.add('staggered-2');
                        } else if (index === 2) {
                            dateLabel.classList.add('staggered-3');
                        } else {
                            // For more than 4 markers at same position, hide additional labels
                            dateLabel.style.display = 'none';
                        }
                    });
                }
            });

            // Click-to-highlight behavior
            if (!window.peerTimelineSelection) window.peerTimelineSelection = {};
            const selectedKey = window.peerTimelineSelection[containerId] || null;
            function applyHighlight(key) {
                const markers = timeline.querySelectorAll('.timeline-marker');
                markers.forEach(m => {
                    const isSelectedFacility = m.dataset.isSelected === 'true';
                    // Keep selected facility markers highlighted
                    if (isSelectedFacility) {
                        m.classList.remove('dimmed');
                    } else if (!key || m.dataset.key === key) {
                        m.classList.remove('dimmed');
                        // Store original size if not already stored
                        if (!m.dataset.originalWidth) {
                            m.dataset.originalWidth = m.style.width || '';
                            m.dataset.originalHeight = m.style.height || '';
                            m.dataset.originalBorder = m.style.border || '';
                            m.dataset.originalBoxShadow = m.style.boxShadow || '';
                        }
                        // Make highlighted peer markers larger to match selected facility
                        if (key && m.dataset.key === key) {
                            m.style.width = '16px';
                            m.style.height = '16px';
                            m.style.border = '3px solid white';
                            m.style.boxShadow = '0 0 8px rgba(45, 55, 72, 0.6)';
                        }
                    } else {
                        m.classList.add('dimmed');
                        // Restore original size if was previously highlighted
                        if (m.dataset.originalWidth) {
                            m.style.width = m.dataset.originalWidth;
                            m.style.height = m.dataset.originalHeight;
                            m.style.border = m.dataset.originalBorder;
                            m.style.boxShadow = m.dataset.originalBoxShadow;
                        }
                    }
                });
                info.querySelectorAll('.legend-item').forEach(li => {
                    if (key && li.getAttribute('data-key') === key) li.classList.add('active'); else li.classList.remove('active');
                });
            }
            if (selectedKey) applyHighlight(selectedKey);

            info.querySelectorAll('.legend-item').forEach(li => {
                li.addEventListener('click', () => {
                    const key = li.getAttribute('data-key');
                    if (window.peerTimelineSelection[containerId] === key) {
                        window.peerTimelineSelection[containerId] = null;
                        applyHighlight(null);
                    } else {
                        window.peerTimelineSelection[containerId] = key;
                        applyHighlight(key);
                    }
                });
            });

            timeline.querySelectorAll('.timeline-marker').forEach(m => {
                m.addEventListener('click', () => {
                    const key = m.dataset.key;
                    if (window.peerTimelineSelection[containerId] === key) {
                        window.peerTimelineSelection[containerId] = null;
                        applyHighlight(null);
                    } else {
                        window.peerTimelineSelection[containerId] = key;
                        applyHighlight(key);
                    }
                });
            });
        }

        /* ============================================================
           REQUIRED: SECTION 2 DEDUPLICATION - DO NOT DELETE
           This function filters by CCN, deduplicates dates, and shows
           facility names matching the CCN from Section 1.
           ============================================================ */
        async function addTimelineMarkers(surveyDates, facilityName, state, defaultCcn = '') {
            if (!surveyDates || surveyDates.length === 0) {
                const timelineContainer = document.getElementById('timelineContainer');
                timelineContainer.innerHTML = `
                    <div class="timeline">
                        <div class="timeline-line"></div>
                        <div class="timeline-scale">
                            <div class="timeline-scale-item">1/1/2016</div>
                            <div class="timeline-scale-item">1/1/2018</div>
                            <div class="timeline-scale-item">1/1/2020</div>
                            <div class="timeline-scale-item">1/1/2022</div>
                            <div class="timeline-scale-item">1/1/2025</div>
                            <div class="timeline-scale-item">12/31/2027</div>
                        </div>
                    </div>
                    <div class="timeline-info">
                        <h4>No Survey Dates Found</h4>
                        <p>No health survey dates were found for <strong>${facilityName}</strong> in <strong>${state}</strong> during the specified time period.</p>
                        <p>This may indicate that no surveys were conducted or the facility has no survey data in the system.</p>
                    </div>
                `;
                return;
            }
            
            // Helper to normalize CCN (strip leading zeros, pad to 6 digits)
            function normalizeCcn(ccn) {
                if (!ccn) return '';
                let normalized = String(ccn).trim().replace(/^0+/, '');
                return normalized.padStart(6, '0') || '';
            }
            
            // Get CCN from Section 1's selected facility FIRST (before filtering)
            let section1Ccn = defaultCcn || '';
            const facilitySelect = document.getElementById('facilitySelect');
            if (facilitiesData && facilitySelect && facilitySelect.value) {
                const selectedFacility = facilitiesData.find(f => 
                    (f.unique_id || f.id || f.CCN || f['CMS Certification Number'] || f['CMS Certification Number (CCN)']) == facilitySelect.value
                );
                if (selectedFacility) {
                    section1Ccn = selectedFacility['CMS Certification Number (CCN)'] || 
                                selectedFacility['CMS Certification Number'] || 
                                selectedFacility['CCN'] || 
                                selectedFacility['ccn'] || 
                                defaultCcn || '';
                }
            }
            
            const targetCcn = normalizeCcn(section1Ccn);
            
            console.log('Section 2 - CCN from Section 1:', { section1Ccn, targetCcn, defaultCcn });
            console.log('Section 2 - Survey dates count:', surveyDates.length);
            
            // Fetch provider names for the target CCN (all historical names for this CCN)
            let providerNamesForCcn = [facilityName];
            if (targetCcn) {
                try {
                    const namesResponse = await fetch(`/api/provider-names/${targetCcn}`);
                    if (namesResponse.ok) {
                        const namesData = await namesResponse.json();
                        if (namesData.provider_names && namesData.provider_names.length > 0) {
                            providerNamesForCcn = namesData.provider_names;
                        }
                    }
                } catch (error) {
                    console.error('Error fetching provider names:', error);
                }
            }
            const primaryProviderName = providerNamesForCcn[0] || facilityName;
            
            // Map survey dates and normalize CCNs
            let filteredDates = surveyDates
                .map(dateInfo => ({
                    ...dateInfo,
                    ccn: dateInfo.ccn || dateInfo.CCN || '',
                    normalizedCcn: normalizeCcn(dateInfo.ccn || dateInfo.CCN || '')
                }));
            
            console.log('Section 2 - Dates with CCN info:', filteredDates.filter(d => d.normalizedCcn && d.normalizedCcn.length > 0).length);
            
            // Try to filter by CCN from Section 1, but be lenient:
            // The API endpoint should already filter by facility, so all dates should be for the selected facility.
            // We'll try to filter by CCN if possible, but won't exclude dates if CCN matching fails.
            if (targetCcn && targetCcn.length > 0) {
                const datesMatchingCcn = filteredDates.filter(d => {
                    // If date has no CCN info, include it (API already filtered by facility)
                    if (!d.normalizedCcn || d.normalizedCcn.length === 0) {
                        return true;
                    }
                    // If date has CCN info, only include if it matches Section 1 CCN
                    return d.normalizedCcn === targetCcn;
                });
                
                console.log('Section 2 - Dates matching CCN:', datesMatchingCcn.length);
                
                // Only use filtered results if we still have dates (don't filter everything out)
                if (datesMatchingCcn.length > 0) {
                    filteredDates = datesMatchingCcn;
                } else {
                    console.log('Section 2 - No dates matched CCN, showing all dates (API already filtered by facility)');
                }
                // If filtering removed all dates, keep original dates (CCN format might differ)
            } else {
                console.log('Section 2 - No target CCN, showing all dates');
            }
            
            console.log('Section 2 - Final filtered dates count:', filteredDates.length);
            
            // Deduplicate by date (keep unique dates only)
            const dateMap = new Map();
            filteredDates.forEach(dateInfo => {
                const dateKey = new Date(dateInfo.date).toISOString().split('T')[0];
                if (!dateMap.has(dateKey)) {
                    dateMap.set(dateKey, dateInfo);
                } else if (!dateMap.get(dateKey).facility_name && dateInfo.facility_name) {
                    dateMap.set(dateKey, dateInfo);
                }
            });
            
            const uniqueSurveyDates = Array.from(dateMap.values())
                .sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const timeline = document.querySelector('.timeline');
            const timelineInfo = document.querySelector('.timeline-info');
            
            // Display CCN from Section 1
            const displayCcn = targetCcn || section1Ccn || 'N/A';
            
            // Helper function to normalize facility names for comparison (trim, lowercase)
            function normalizeName(name) {
                return (name || '').trim().toLowerCase();
            }
            
            // Create a set of valid provider names (normalized) for quick lookup
            const validProviderNamesSet = new Set(providerNamesForCcn.map(n => normalizeName(n)));
            
            // Update info with deduplicated dates, using facility_name from each date
            // Only use facility_name if it matches one of the valid provider names for this CCN
            const datesList = uniqueSurveyDates
                .map(d => {
                    const dateStr = new Date(d.date).toLocaleDateString();
                    // Check if the facility_name from the date record matches a valid provider name for this CCN
                    let facilityNameForDate = d.facility_name || '';
                    const normalizedDateName = normalizeName(facilityNameForDate);
                    
                    // If the date's facility_name is not in the valid list, use the primary provider name
                    if (!facilityNameForDate || !validProviderNamesSet.has(normalizedDateName)) {
                        facilityNameForDate = primaryProviderName;
                    }
                    
                    return `<li>${dateStr} - ${facilityNameForDate}</li>`;
                })
                .join('');
            timelineInfo.innerHTML = `
                <h4>Survey Dates Found: ${uniqueSurveyDates.length} unique dates</h4>
                <p><strong>Facility:</strong> ${primaryProviderName}</p>
                <p><strong>CCN:</strong> ${displayCcn}</p>
                <p><strong>State:</strong> ${state}</p>
                <p>Click on a marker to see details</p>
                <h5>All Survey Dates</h5>
                <ul>${datesList}</ul>
            `;
            
            // Store data for later retrieval
            timelineInfo.setAttribute('data-survey-dates', JSON.stringify(uniqueSurveyDates));
            timelineInfo.setAttribute('data-facility-name', primaryProviderName);
            timelineInfo.setAttribute('data-state', state);
            timelineInfo.setAttribute('data-ccn', displayCcn !== 'N/A' ? displayCcn : targetCcn);
            
            // Add markers for each unique survey date
            uniqueSurveyDates.forEach((dateInfo) => {
                const marker = document.createElement('div');
                marker.className = 'timeline-marker';
                marker.title = `Survey Date: ${dateInfo.date}`;
                marker.style.width = '16px';
                marker.style.height = '16px';
                marker.style.border = '3px solid white';
                marker.style.boxShadow = '0 0 8px rgba(45, 55, 72, 0.6)';
                
                // Calculate position (1/1/2016 to 12/31/2027)
                const startDate = new Date('2016-01-01');
                const endDate = new Date('2027-12-31');
                const surveyDate = new Date(dateInfo.date);
                const totalDays = (endDate - startDate) / (1000 * 60 * 60 * 24);
                const daysFromStart = (surveyDate - startDate) / (1000 * 60 * 60 * 24);
                const position = (daysFromStart / totalDays) * 100;
                marker.style.left = `${Math.max(0, Math.min(100, position))}%`;
                
                const dateLabel = document.createElement('div');
                dateLabel.className = 'timeline-date';
                dateLabel.textContent = new Date(dateInfo.date).toLocaleDateString();
                marker.appendChild(dateLabel);
                
                marker.addEventListener('click', () => {
                    showMarkerDetails(dateInfo, marker, primaryProviderName);
                });
                
                timeline.appendChild(marker);
            });
        }
        /* ============================================================ */
        
        /* ============================================================
           REQUIRED: SECTION 2 MARKER DETAILS - DO NOT DELETE
           Shows marker details with deduplicated dates and provider names.
           ============================================================ */
        async function showMarkerDetails(dateInfo, marker, primaryProviderNameFromSection1) {
            document.querySelectorAll('.timeline-marker').forEach(m => m.classList.remove('active'));
            marker.classList.add('active');
            
            const timelineInfo = document.querySelector('.timeline-info');
            
            // Get CCN from Section 1's selected facility FIRST
            const facilitySelect = document.getElementById('facilitySelect');
            let section1Ccn = '';
            if (facilitiesData && facilitySelect && facilitySelect.value) {
                const selectedFacility = facilitiesData.find(f => 
                    (f.unique_id || f.id || f.CCN || f['CMS Certification Number'] || f['CMS Certification Number (CCN)']) == facilitySelect.value
                );
                if (selectedFacility) {
                    section1Ccn = selectedFacility['CMS Certification Number (CCN)'] || 
                                selectedFacility['CMS Certification Number'] || 
                                selectedFacility['CCN'] || 
                                selectedFacility['ccn'] || 
                                '';
                }
            }
            
            // Helper to normalize CCN
            function normalizeCcn(ccn) {
                if (!ccn) return '';
                return String(ccn).trim().replace(/^0+/, '').padStart(6, '0') || '';
            }
            
            const targetCcnNormalized = normalizeCcn(section1Ccn);
            const ccnDisplay = targetCcnNormalized || section1Ccn || dateInfo.ccn || 'N/A';
            
            const surveyDates = JSON.parse(timelineInfo.getAttribute('data-survey-dates') || '[]');
            const facilityName = timelineInfo.getAttribute('data-facility-name') || 'Unknown Facility';
            const state = timelineInfo.getAttribute('data-state') || 'Unknown State';
            const storedCcn = timelineInfo.getAttribute('data-ccn') || '';
            
            // Fetch provider names for the CCN from Section 1 (all historical names for this CCN)
            let providerNamesForCcn = [primaryProviderNameFromSection1 || facilityName];
            if (targetCcnNormalized) {
                try {
                    const namesResponse = await fetch(`/api/provider-names/${targetCcnNormalized}`);
                    if (namesResponse.ok) {
                        const namesData = await namesResponse.json();
                        if (namesData.provider_names && namesData.provider_names.length > 0) {
                            providerNamesForCcn = namesData.provider_names;
                        }
                    }
                } catch (error) {
                    console.error('Error fetching provider names in showMarkerDetails:', error);
                }
            }
            const primaryProviderName = providerNamesForCcn[0] || primaryProviderNameFromSection1 || facilityName;
            
            // Helper function to normalize facility names for comparison (trim, lowercase)
            function normalizeName(name) {
                return (name || '').trim().toLowerCase();
            }
            
            // Create a set of valid provider names (normalized) for quick lookup
            const validProviderNamesSet = new Set(providerNamesForCcn.map(n => normalizeName(n)));
            
            // Deduplicate again to ensure no duplicates
            const dateMap = new Map();
            surveyDates.forEach(d => {
                const dateKey = new Date(d.date).toISOString().split('T')[0];
                if (!dateMap.has(dateKey)) dateMap.set(dateKey, d);
            });
            
            // Filter to only dates matching the CCN from Section 1, but be lenient
            const uniqueDates = Array.from(dateMap.values())
                .filter(d => {
                    if (!targetCcnNormalized || targetCcnNormalized.length === 0) return true; // If no CCN from Section 1, show all
                    const dCcn = normalizeCcn(d.ccn || d.CCN || '');
                    // If date has no CCN info, include it (API already filtered by facility)
                    if (!dCcn || dCcn.length === 0) return true;
                    // If date has CCN info, only include if it matches Section 1 CCN
                    return dCcn === targetCcnNormalized;
                })
                .sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const datesList = uniqueDates
                .map(d => {
                    const dateStr = new Date(d.date).toLocaleDateString();
                    // Check if the facility_name from the date record matches a valid provider name for this CCN
                    let facilityNameForDate = d.facility_name || '';
                    const normalizedDateName = normalizeName(facilityNameForDate);
                    
                    // If the date's facility_name is not in the valid list, use the primary provider name
                    if (!facilityNameForDate || !validProviderNamesSet.has(normalizedDateName)) {
                        facilityNameForDate = primaryProviderName;
                    }
                    
                    return `<li>${dateStr} - ${facilityNameForDate}</li>`;
                })
                .join('');
            
            timelineInfo.innerHTML = `
                <h4>Survey Date Details (Selected)</h4>
                <p><strong>Date:</strong> ${new Date(dateInfo.date).toLocaleDateString()}</p>
                <p><strong>Facility:</strong> ${primaryProviderName}</p>
                <p><strong>State:</strong> ${dateInfo.state || state}</p>
                <p><strong>CCN:</strong> ${ccnDisplay}</p>
                <hr style="margin: 15px 0; border: none; border-top: 1px solid #ddd;">
                <h5>All Survey Dates (${uniqueDates.length} unique dates)</h5>
                <p><strong>CCN:</strong> ${ccnDisplay}</p>
                <ul>${datesList}</ul>
            `;
            
            timelineInfo.setAttribute('data-survey-dates', JSON.stringify(uniqueDates));
            timelineInfo.setAttribute('data-facility-name', primaryProviderName);
            timelineInfo.setAttribute('data-state', state);
            timelineInfo.setAttribute('data-ccn', targetCcnNormalized || section1Ccn || storedCcn);
        }
        /* ============================================================ */

        async function renderStateTrends(state) {
            try {
                const resp = await fetch(`/api/state-deficiency-trends/${encodeURIComponent(state)}`);
                if (!resp.ok) return { listHtml: '', summaryHtml: '' };
                const data = await resp.json();
                const listHtml = (data.state_trends || [])
                    .map(t => `<li>${t.category}: ${t.count}</li>`)
                    .join('');
                const summaryHtml = data.state_trend_summary || '';
                return { listHtml, summaryHtml };
            } catch (_) {
                return { listHtml: '', summaryHtml: '' };
            }
        }
        
        async function renderCountyTrends(state, county) {
            try {
                if (!county) return { listHtml: '', summaryHtml: '' };
                const resp = await fetch(`/api/county-deficiency-trends/${encodeURIComponent(state)}/${encodeURIComponent(county)}`);
                if (!resp.ok) return { listHtml: '', summaryHtml: '' };
                const data = await resp.json();
                const listHtml = (data.county_trends || [])
                    .map(t => `<li>${t.category}: ${t.count}</li>`)
                    .join('');
                const summaryHtml = data.county_trend_summary || '';
                return { listHtml, summaryHtml };
            } catch (_) {
                return { listHtml: '', summaryHtml: '' };
            }
        }

        async function fetchDeficiencies(facility) {
            try {
                const container = document.getElementById('deficienciesContainer');
                // Get facility ID - handle unique_id = 0 correctly
                const facilityId = facility.unique_id !== undefined && facility.unique_id !== null 
                    ? facility.unique_id 
                    : (facility['CMS Certification Number (CCN)'] || facility['CMS Certification Number'] || facility.CCN || facility.id || 0);
                const state = facility.State || facility['State'];
                const ccn = facility['CMS Certification Number (CCN)'] || facility['CMS Certification Number'] || facility.CCN || facility.ccn || '';
                
                console.log('üîç Fetching deficiencies for facility:', { facilityId, state, ccn });
                console.log('üîç Full facility object:', facility);
                console.log('üîç Available CCN fields:', {
                    'CMS Certification Number (CCN)': facility['CMS Certification Number (CCN)'],
                    'CMS Certification Number': facility['CMS Certification Number'],
                    'CCN': facility.CCN,
                    'ccn': facility.ccn
                });
                
                if (!state) {
                    console.error('üîç Missing state for deficiencies');
                    container.innerHTML = '<div class="error">State information is required to load deficiencies</div>';
                    return;
                }
                
                if (facilityId === undefined || facilityId === null) {
                    console.error('üîç Missing facility ID for deficiencies');
                    container.innerHTML = '<div class="error">Facility ID is required to load deficiencies</div>';
                    return;
                }
                
                container.innerHTML = '<div class="loading">Loading deficiencies...</div>';
                const params = new URLSearchParams();
                if (ccn) params.set('ccn', ccn);
                
                const url = `/api/deficiencies/${encodeURIComponent(state)}/${encodeURIComponent(facilityId)}?${params.toString()}`;
                console.log('üîç Deficiencies API URL:', url);
                console.log('üîç CCN being sent to API:', ccn);
                console.log('üîç URLSearchParams:', params.toString());
                
                const res = await fetch(url);
                console.log('üîç Deficiencies API response status:', res.status);
                
                if (!res.ok) {
                    const errorText = await res.text();
                    console.error('üîç Deficiencies API error:', errorText);
                    throw new Error(`Failed to fetch deficiencies: ${res.status} - ${errorText}`);
                }
                
                const data = await res.json();
                console.log('üîç Deficiencies API data:', data);
                
                // Also fetch state-level trends
                const { listHtml: stateTrendsHtml, summaryHtml: stateSummaryHtml } = await renderStateTrends(state);
                
                // Also fetch county-level trends
                const county = facility['County/Parish'] || '';
                const { listHtml: countyTrendsHtml, summaryHtml: countySummaryHtml } = await renderCountyTrends(state, county);
                
                renderDeficiencies(container, { ...data, stateTrendsHtml, stateSummaryHtml, countyTrendsHtml, countySummaryHtml });
            } catch (e) {
                console.error('üîç Error fetching deficiencies:', e);
                const container = document.getElementById('deficienciesContainer');
                container.innerHTML = `<div class="error">Error loading deficiencies: ${e.message}</div>`;
            }
        }

        function renderDeficiencies(container, data) {
            console.log('üîç Rendering deficiencies data:', data);
            console.log('üîç Facility deficiencies count:', data.facility_deficiencies?.length || 0);
            console.log('üîç ZIP deficiencies count:', data.zip_deficiencies?.length || 0);
            
            const facilityList = (data.facility_deficiencies || []).map(r => {
                const date = new Date(r['Survey Date']).toLocaleDateString();
                return `<li><strong>${date}</strong> ‚Äî [${r['Deficiency Category']}] Tag ${r['Deficiency Tag Number']}: ${r['Deficiency Description']}</li>`;
            }).join('');
            
            // Simplified ZIP list: group by (Provider Name, Survey Date) and count deficiencies
            const zipGroups = new Map();
            (data.zip_deficiencies || []).forEach(r => {
                const provider = r['Provider Name'] || 'Unknown Facility';
                const d = new Date(r['Survey Date']);
                const keyDate = isNaN(d) ? String(r['Survey Date']) : d.toISOString().slice(0, 10);
                const key = `${provider}||${keyDate}`;
                zipGroups.set(key, (zipGroups.get(key) || 0) + 1);
            });
            const zipList = Array.from(zipGroups.entries())
                .sort((a, b) => {
                    // sort by date then provider
                    const [pa, da] = a[0].split('||');
                    const [pb, db] = b[0].split('||');
                    if (da !== db) return da.localeCompare(db);
                    return pa.localeCompare(pb);
                })
                .map(([key, count]) => {
                    const [provider, dateIso] = key.split('||');
                    const displayDate = (() => {
                        const d = new Date(dateIso);
                        return isNaN(d) ? dateIso : d.toLocaleDateString();
                    })();
                    return `<li><strong>${provider}</strong> ‚Äî ${displayDate} ‚Äî ${count} deficiencies</li>`;
                })
                .join('');
            
            const trends = (data.zip_trends || []).map(t => `<li>${t.category}: ${t.count}</li>`).join('');
            const summary = data.trend_summary || '';
            const stateTrendsHtml = data.stateTrendsHtml || '';
            const stateSummaryHtml = data.stateSummaryHtml || '';

            // Save for prompt generation
            window._lastDefTrends = {
                zipTrendsHtml: trends,
                zipSummary: summary,
                countyTrendsHtml: data.countyTrendsHtml || '',
                countySummaryHtml: data.countySummaryHtml || '',
                stateTrendsHtml: stateTrendsHtml,
                stateSummaryHtml: stateSummaryHtml,
                stateCode: (document.getElementById('stateSelect') || {}).value || ''
            };
            
            container.innerHTML = `
                <div class="info-grid">
                    <div class="info-item" style="grid-column: 1 / -1;">
                        <div class="info-label">Deficiencies for Selected Facility</div>
                        <div class="info-value">
                            <ul>${facilityList || '<li>No deficiencies found.</li>'}</ul>
                        </div>
                    </div>
                    <div class="info-item" style="grid-column: 1 / -1;">
                        <div class="info-label">Deficiencies for Facilities in ZIP ${data.zip || ''}</div>
                        <div class="info-value">
                            <ul>${zipList || '<li>No deficiencies found.</li>'}</ul>
                        </div>
                    </div>
                    <div class="info-item" style="grid-column: 1 / -1;">
                        <div class="info-label">Trends in Frequency (ZIP ${data.zip || ''})</div>
                        <div class="info-value">
                            <ul>${trends || '<li>No trends found.</li>'}</ul>
                        </div>
                    </div>
                    <div class="info-item" style="grid-column: 1 / -1;">
                        <div class="info-label">Trend Description</div>
                        <div class="info-value">${summary}</div>
                    </div>
                    <div class="info-item" style="grid-column: 1 / -1;">
                        <div class="info-label">Trends in Frequency (County)</div>
                        <div class="info-value">
                            <ul>${data.countyTrendsHtml || '<li>No trends found.</li>'}</ul>
                        </div>
                    </div>
                    <div class="info-item" style="grid-column: 1 / -1;">
                        <div class="info-label">Trend Description (County)</div>
                        <div class="info-value">${data.countySummaryHtml || 'No county data available.'}</div>
                    </div>
                    <div class="info-item" style="grid-column: 1 / -1;">
                        <div class="info-label">Trends in Frequency (State ${data.state || ''})</div>
                        <div class="info-value">
                            <ul>${stateTrendsHtml || '<li>No trends found.</li>'}</ul>
                        </div>
                    </div>
                    <div class="info-item" style="grid-column: 1 / -1;">
                        <div class="info-label">Trend Description (State)</div>
                        <div class="info-value">${stateSummaryHtml}</div>
                    </div>
                </div>
            `;
        }
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Dashboard loaded successfully');
            
            // Populate state dropdown from API FIRST (critical for user interaction)
            console.log('Attempting to populate state dropdown...');
            const stateSelect = document.getElementById('stateSelect');
            if (!stateSelect) {
                console.error('‚ùå State select element not found in DOM!');
            } else {
                console.log('‚úÖ State select element found');
                try {
                    populateStateDropdown().catch(err => {
                        console.error('Error in populateStateDropdown promise:', err);
                        // Ensure fallback is called even if async fails
                        populateFallbackStates();
                    });
                } catch (error) {
                    console.error('Error calling populateStateDropdown:', error);
                    // Ensure fallback is called
                    populateFallbackStates();
                }
            }
            
            // Set date input minimum to today
            try {
                setDateInputMin();
            } catch (error) {
                console.error('Error setting date input min:', error);
            }
            
            // Update Section 3 timeline end date to 15 months from today
            try {
                const today = new Date();
                const endDate15Months = new Date(today);
                endDate15Months.setMonth(today.getMonth() + 15);
                const endDateElement = document.getElementById('peerTimelineEndDate');
                if (endDateElement) {
                    const month = endDate15Months.getMonth() + 1;
                    const year = endDate15Months.getFullYear();
                    endDateElement.textContent = `${month}/1/${year}`;
                }
            } catch (error) {
                console.error('Error updating Section 3 timeline end date:', error);
            }
            
            // Initialize map
            try {
                initializeMap();
            } catch (error) {
                console.error('Error initializing map:', error);
            }
            
            // Initialize map slider
            const dateSlider = document.getElementById('dateSlider');
            if (dateSlider) {
                dateSlider.addEventListener('input', function() {
                    updateDateDisplay(this.value);
                    updateMapForDate(this.value);
                });
            }
            
            // Initialize auto-play controls
            const playPauseBtn = document.getElementById('playPauseBtn');
            const resetBtn = document.getElementById('resetBtn');
            
            if (playPauseBtn) {
                playPauseBtn.addEventListener('click', function() {
                    if (isPlaying) {
                        stopAutoPlay();
                    } else {
                        startAutoPlay();
                    }
                });
            }
            
            if (resetBtn) {
                resetBtn.addEventListener('click', resetTimeline);
            }
            const monthPicker = document.getElementById('monthPicker');
            const display = document.getElementById('selectedMonthDisplay');
            const valueEl = document.getElementById('selectedMonthValue');
            if (monthPicker && display && valueEl) {
                monthPicker.addEventListener('change', () => {
                    const val = monthPicker.value; // format YYYY-MM
                    if (val) {
                        const [y, m] = val.split('-');
                        const dt = new Date(parseInt(y,10), parseInt(m,10) - 1, 1);
                        const label = dt.toLocaleString(undefined, { month: 'long', year: 'numeric' });
                        valueEl.textContent = label;
                        display.style.display = 'block';
                    } else {
                        display.style.display = 'none';
                    }
                });
            }
            const promptBtn = document.getElementById('createPromptBtn');
            if (promptBtn) {
                promptBtn.addEventListener('click', () => {
                    // Placeholder for future behavior
                    alert('Create Prompt clicked');
                });
            }
        });

        // Helper: get facility CCN using multiple possible fields
        function getFacilityCcn(facility) {
            return facility.CCN || facility.ccn || facility['CMS Certification Number'] || facility['CMS Certification Number (CCN)'] || facility.unique_id || Object.values(facility)[0];
        }

        // Merge selected facility historical survey dates into map surveyData
        async function mergeSelectedFacilitySurveysIntoMap(selectedFacility) {
            try {
                const state = selectedFacility.State || selectedFacility['State'];
                const facilityId = selectedFacility.unique_id || selectedFacility.id || selectedFacility.CCN || selectedFacility['CMS Certification Number'] || selectedFacility['CMS Certification Number (CCN)'];
                if (!state || !facilityId) return;

                // Fetch historical survey dates for selected facility
                const resp = await fetch(`/api/facility-survey-dates/${encodeURIComponent(state)}/${encodeURIComponent(facilityId)}`);
                if (!resp.ok) return;
                const data = await resp.json();
                const dates = Array.isArray(data) ? data : (data.survey_dates || []);

                if (!Array.isArray(dates) || dates.length === 0) return;

                const ccn = getFacilityCcn(selectedFacility);
                const name = selectedFacility['Provider Name'] || selectedFacility.name || selectedFacility['Facility Name'] || 'Selected Facility';

                // Build a set to dedupe by ccn+dateKey
                const toYMD = (d) => {
                    const y = d.getUTCFullYear();
                    const m = String(d.getUTCMonth() + 1).padStart(2, '0');
                    const dd = String(d.getUTCDate()).padStart(2, '0');
                    return `${y}-${m}-${dd}`;
                };
                const existingKeys = new Set((surveyData || []).map(s => `${s.ccn}|${toYMD(s.date instanceof Date ? s.date : new Date(s.date))}`));

                dates.forEach(ds => {
                    const d = ds instanceof Date ? ds : new Date(ds);
                    if (isNaN(d.getTime())) return;
                    const key = `${ccn}|${toYMD(d)}`;
                    if (!existingKeys.has(key)) {
                        surveyData.push({ ccn: ccn, date: d, facility_name: name });
                        existingKeys.add(key);
                    }
                });

                // Recompute dateRange if needed
                const allDates = surveyData.map(s => (s.date instanceof Date ? s.date : new Date(s.date))).filter(d => !isNaN(d));
                if (allDates.length > 0) {
                    const minD = new Date(Math.min(...allDates.map(d => d.getTime())));
                    const maxD = new Date(Math.max(...allDates.map(d => d.getTime())));
                    dateRange.min = minD;
                    dateRange.max = maxD;

                    // Update slider bounds
                    const slider = document.getElementById('dateSlider');
                    if (slider) {
                        slider.min = 0;
                        slider.max = Math.max(0, Math.floor((dateRange.max - dateRange.min) / (1000 * 60 * 60 * 24)));
                    }
                }

                console.log(`üß© Merged ${dates.length} historical survey dates for selected facility into map data.`);
            } catch (e) {
                console.log('üß© mergeSelectedFacilitySurveysIntoMap error:', e);
            }
        }

        // Wire up Get Schedule button to call backend and populate Section 9
        /* ============================================================
           REQUIRED: SECTION 8 GET SCHEDULE BUTTON FEEDBACK - DO NOT DELETE
           Provides user feedback when generating schedules.
           ============================================================ */
        (function attachGetScheduleHandler(){
            document.addEventListener('DOMContentLoaded', function() {
                const btn = document.getElementById('getScheduleBtn');
                if (!btn) return;
                btn.addEventListener('click', async function() {
                    // User feedback before API call
                    alert('The schedule generation request has been submitted. This may take 2-3 minutes to complete. You will be notified when the result is ready.');
                    try {
                        const textarea = document.getElementById('promptTextarea');
                        const prompt = textarea ? textarea.value.trim() : '';
                        if (!prompt) { alert('Prompt is empty. Please generate or enter a prompt.'); return; }

                        const resp = await fetch('/api/generate-schedule', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ prompt })
                        });
                        if (!resp.ok) {
                            const t = await resp.text();
                            throw new Error(`Failed to generate schedule: ${resp.status} ${t}`);
                        }
                        const data = await resp.json();
                        console.log('DEBUG: Received data from backend:', data);  // Debug log
                        // Show Section 9
                        const section9 = document.getElementById('scheduleSection');
                        if (section9) {
                            section9.style.display = 'block';
                            // User feedback after completion
                            alert('Schedule generation complete! The results are now available in Section 9.');
                            if (section9.scrollIntoView) section9.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                        const out = document.getElementById('genaiOutput');
                        if (out) out.textContent = data.text || '';
                        const tj = document.getElementById('todoistJson');
                        if (tj) tj.value = data.todoist_json || '';
                        console.log('DEBUG: Set todoistJson textarea to:', data.todoist_json);  // Debug log
                    } catch (e) {
                        alert(e.message || String(e));
                    }
                });
            });
        })();

        (function attachTodoistImportHandler(){
            document.addEventListener('DOMContentLoaded', function(){
                const btn = document.getElementById('importTodoistBtn');
                if (!btn) return;
                btn.addEventListener('click', async function(){
                    try {
                        const tokenEl = document.getElementById('todoistTokenInput');
                        const jsonEl = document.getElementById('todoistJson');
                        const token = tokenEl ? tokenEl.value.trim() : '';
                        const jsonText = jsonEl ? jsonEl.value.trim() : '';
                        if (!token) { alert('Please enter your Todoist token.'); return; }
                        if (!jsonText) { alert('ToDoist JSON is empty.'); return; }
                        const resp = await fetch('/api/import-todoist', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ token, todoist_json: jsonText })
                        });
                        const payload = await resp.json().catch(() => ({}));
                        if (!resp.ok) {
                            throw new Error(payload.error || `Import failed with status ${resp.status}`);
                        }
                        alert('ToDoist import completed successfully.');
                    } catch (e) {
                        alert(e.message || String(e));
                    }
                });
            });
        })();
    </script>
    <P></P>

</body>
</html>

